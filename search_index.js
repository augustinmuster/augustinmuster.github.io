var documenterSearchIndex = {"docs":
[{"location":"example_yagi_uda/#Example:-Yagi-Uda-Antenna-Made-Out-of-Silicon-particles.","page":"Yagi-Uda Antenna","title":"Example: Yagi-Uda Antenna Made Out of Silicon particles.","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"In this example, we will simulate a Yagi-Uda antenna made out of small silicon spheres (like in Krasnok et al., Opt. Express 20, 20599-20604 (2012), click here for more information). For this, we will create a linear structure of small particles as follows: ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/YU_design.png\">","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Note that the spacings described below have to be understood as center-to center spacing. At the origin, we place a silicon sphere with a radius of 245nm called the reflector. After a bigger spacing of 245nm + 355nm + 800nm + 200nm = 2600 nm within which we will place the emitter (an oscillating dipole source aligned along the y-axis) at a distance of 600 nm from the origin, we align 10 silicon spheres, called directors, on the z-axis and with a radius of 200nm, (center to center spacing: 800nm). We will then compute the emission pattern of this structure, in order to investigate the directionality of this antenna.  ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"We suppose that you already know the example of the PS sphere. So if you haven't had a look to it before, read it first. If you want to know about the electric and magnetic CEMD problem, have a look at the theory as well.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If you want to run this example, copy it or download it from the GitHub repository (example_yagi_uda.jl) and run it using ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"julia example_yagi_uda.jl\n","category":"page"},{"location":"example_yagi_uda/#Setting-the-Structure","page":"Yagi-Uda Antenna","title":"Setting the Structure","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"We will first start to model the structure of the antenna in an array 'r' containing the positions of each of its components. But first, we need to import some libraries. ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Then, we can set the parameters (sizes) of the antenna and build the structure.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"##################### Parameters ########################################\n#radius of the sphere (in μm)\na_refl=0.245 #reflector radius\na_dir=0.200 #director radius\nN_dir=10 #number of directors\n#dielectric constant of the particle\neps=12\n#wavelength (in μm) \nlambda=1.550\n##########################################################################\n\n#setting the structure\n#creates an array to contain the positions\nr=zeros(N_dir+1,3)\n\n#spacing between reflector and first director\nspacing_ref_dir=a_refl+0.355+0.800+a_dir\n#spacing between directors\nspacing_dirs=4*a_dir\n\n#sets the position of the directors (reflector is at the origin)\nfor i=2:N_dir+1\n    r[i,3]=spacing_ref_dir+(i-2)*spacing_dirs\nend\n\n#creates an array containing the radius of each sphere\nas=a_dir*ones(N_dir+1)\nas[1]=a_refl","category":"page"},{"location":"example_yagi_uda/#Modelling-silicon-particles","page":"Yagi-Uda Antenna","title":"Modelling silicon particles","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Now that we set the position of each of the antenna's components, we need to model their optical response. To do this, let's open a small parenthesis and try to model a sphere with a radius of 0.230 μm using only one electric and magnetic dipole per particle (no discretization like in the PS sphere example). For this, we set the electric and magnetic polarizabilities of the particles to be proportional to the two first Mie coefficients a_1 and b_1. For this, we use the MieCoeff module to get the Mie coefficients and to compare the scattering efficiency Q_sca of the sphere computed with only the first Mie coefficient and the truncated series (cut after 20 terms). ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#------------------modelling silicon particles---------------\n#parameter\nlambdas=LinRange(1.200,1.600,100)\nknorms=2*pi./lambdas\na=0.230\nka = knorms*a\neps=12\n#scattering cross sections\nmie_sca=MieCoeff.mie_scattering.(ka,eps,1,cutoff=20)\ndipole_sca=(6*pi)./knorms.^2 .*(abs2.(MieCoeff.mie_an.(ka, eps, 1, n=1)).+abs2.(MieCoeff.mie_bn.(ka, eps, 1, n=1)))\n#plotting\nfig1,ax1=plt.subplots()\nax1.set_xlabel(L\"\\lambda\\ (\\mu m)\")\nax1.set_ylabel(L\"Q_{sca}\")\nax1.plot(lambdas,mie_sca,color=\"black\",label=\"Mie\")\nax1.plot(lambdas,dipole_sca./(pi*a^2),color=\"red\",label=\"Dipoles\")\nfig1.savefig(\"mie_dipole_qsca.svg\")\n#------------------------------------------------------------","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If we plot the scattering efficiency (in red for the dipoles and in black for the Mie theory), we see that the scattering efficiency is reasonably described by only the first two Mie coefficients for any wavelength bigger than 1.2 μm. From this, we conclude that the electric and magnetic dipole excitations are enough to describe the optical response of these spheres. Therefore, the polarizabilities of the components of the antenna can be computed using Alphas.alpha_mie_renorm.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/mie_dipole_qsca.svg\">","category":"page"},{"location":"example_yagi_uda/#Computing-Emission-Pattern","page":"Yagi-Uda Antenna","title":"Computing Emission Pattern","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Now that we know how to model the particles, we can solve the DDA problem of the antenna as follow:","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#computes the wavenumber\nknorm=2*pi/lambda\n#computes the polarizabilities using first mie coefficients\nalpha_e=zeros(ComplexF64,N_dir+1)\nalpha_m=zeros(ComplexF64,N_dir+1)\nfor i=1:N_dir+1 \n    alpha_e[i],alpha_m[i]=Alphas.alpha_e_m_mie(knorm*as[i],eps,1)\nend\n#computes the input input_field\ninput_field=InputFields.point_dipole_e_m(knorm*r,knorm*[0,0,0.355],2)\n\n#solves DDA electric and magnetic\nphi_inc=DDACore.solve_DDA_e_m(knorm*r,alpha_e,alpha_m,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"And, since we know the incident fields, we can compute the emission pattern of the antenna by sampling directions in the y-z plane. Note that the output of the function is given in units of the total power emitted by the dipole P_0.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#sample directions in the y-z plane\nthetas=LinRange(0,2*pi,200)\nur=zeros(200,3)\nur[:,3]=knorm*cos.(thetas)\nur[:,2]=knorm*sin.(thetas)\n\n#emission pattern of the antenna\nres=PostProcessing.emission_pattern_e_m(knorm*r,phi_inc,alpha_e,alpha_m,ur,krd,2)\n\n#plotting\nfig2=plt.figure()\nax2 = fig2.add_subplot(projection=\"polar\")\nax2.set_title(L\"d P/ d \\Omega\\ (P_0)\")\nax2.plot(thetas,res,label=\"y-z plane\")\nax2.legend()\nfig2.savefig(\"diff_P.svg\")","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/diff_P.svg\">","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"After plotting the emission pattern in polar coordinates, we see that the antenna has, as expected, a pronounced directionality in the z direction.","category":"page"},{"location":"alphas/#Polarizabilities","page":"Alphas","title":"Polarizabilities","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"Alphas is a module to load polarizabilities. In this module, you will find functions to compute electric and magnetic polarizabilities of several objects. The module also contains some functions to renormalize polarizabilities and to manage the multiple formats of the polarizabilities (dispatch). The list of functions (as well as how to use them) is given below. Note that N denotes the number of point dipoles in the problem.","category":"page"},{"location":"alphas/#Format-of-the-polarizabilities-in-the-DDACore-and-PostProcessing-functions","page":"Alphas","title":"Format of the polarizabilities in the DDACore and PostProcessing functions","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"The functions of the DDACore and PostProcessing modules come with an automatic dispatch of the format of the polarizability. If we have N dipoles, it can be:","category":"page"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"a complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6","category":"page"},{"location":"alphas/#Functions-Documentation","page":"Alphas","title":"Functions Documentation","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_cube(L,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_cube-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_cube","text":"alpha0_cube(L,eps,eps_h)\n\nComputes the quasistatic polarizability tensor of a cube of side L and permittivity eps in a host medium with permittivity eps_h. Permittivities can be scalars or 3times 3 tensors.  Outputs a 3times 3 float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_sphere(a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere","text":"alpha0_sphere(a,eps,eps_h)\n\nComputes the quasistatic polarizability of a sphere of radius a and permittivity eps in a host medium with permittivity eps_h.  Permittivities can be scalars or 3times 3 tensors. Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_volume(V,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume","text":"alpha0_volume(V,eps,eps_h)\n\nComputes the quasistatic polarizability of any isotropic object with volume V and permittivity eps in a host medium with permittivity eps_h. Permittivities can be scalars or 3times 3 tensors.  Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_radiative(alpha0,knorm)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative","text":"alpha_radiative(alpha0,knorm)\n\nApplies the radiative correction to the polarizability matrix or scalar alpha0 (with units of volume). Outputs a complex dimensionless scalar or a (3x3) complex dimensionless matrix.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie(ka,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie","text":"alpha_e_m_mie(ka,eps,eps_h)\n\nComputes the electric and magnetic polarizabilities from the mie coefficients a_1 and  b_1 of a particle with size parameter ka (wave number times radius), and permittivity eps, in a host medium with permittivity eps_h. Outputs two dimensionless scalars that are respectively the electric and the magnetic polarizability.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e(alpha_e_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e","text":"dispatch_e(alpha_e_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntax for multuplying a Green's tensor by polarizability of a particle.\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntax for multuplying a Green's tensor by the polarizability of a particle.\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nalpha_m_dl: magnetic polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\nalp_m: iterable magnetic polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntax for multuplying a Green's tensor by the polarizability of a particle.\n\nArguments\n\nalpha_dl: polarizability 6x6 complex matrix, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp: iterable polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.renorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha","text":"renorm_alpha(knorm,alpha)\n\nRenormalizes any polarizability alpha with units of volume in a dimensionless polarizability by multiplying by k^34pi. knorm is the wave number in the medium.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.denorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha","text":"denorm_alpha(knorm,alpha)\n\nDenormalizes any dimensionless polarizability alpha in a polarizability with units of volume by multiplying by 4pi k^3. knorm is the wave number in the medium.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#DDA-Core-Functionalities","page":"DDACore","title":"DDA Core Functionalities","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"DDACore is the module allowing to solve DDA/CEMD problems (see the Theory pdf for definition of these problems). The problems can be solved either on the CPU (in parrallel with LAPACK) or on the GPU (With CUDA). The list of functions and how to use them is in the next section. Note that N denotes the number of point dipoles in the problem.","category":"page"},{"location":"ddacore/#Functions-List-and-Documentation","page":"DDACore","title":"Functions List and Documentation","text":"","category":"section"},{"location":"ddacore/#Main-Solver-Functions","page":"DDACore","title":"Main Solver Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e","text":"solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations under a given input field for a group of N only electric dipoles and returns the total incident field on each of the dipoles. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 3, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If input_field=nothing, the output of the function will be the inverse of the DDA matrix.\nsolver: string that contains the name of the solver to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output informations to the standard output during runtime or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole. if input_field is a 2D array.\ne_inc: 3D complex array of size N_ftimes Ntimes 3 containing the incident electric field mathbfE_i on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size 3Ntimes 3N, if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the CEMD equations with dimensionless inputs under a given input field for a group of N electric and magnetic dipoles and return the total incident field on every dipole.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfPhi_0=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 6, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If input_field=nothing (default value), the output of the function will be the inverse of the CEMD matrix.\nsolver:string that contains the name of the solver to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output pieces of information to the standard output during runtime or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole, if input_field is a 2D array.\nphi_inc: 3D complex array of size N_ftimes Ntimes 6 containing the incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size 6Ntimes 6N, if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"function solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nSame as solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#Utility-Functions","page":"DDACore","title":"Utility Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_system(A,b,solver,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_system-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_system","text":" solve_system(A,b,solver,verbose)\n\nSolves a system of equations of the type Ax=b using the method solver and returns x. x can be a 1D column vector or a 2D matrix. In this second case, the function is going to solve for each column of the matrix as a different problem (without re-inverting A). The solver flag can be set to\n\nCPU: In this case, the system is solved using LAPACK on the CPU.\nGPU: In this case, the system is solved using CUSOLVE on the GPU (if available).\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e(kr,alpha_e_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e","text":" load_dda_matrix_e(kr,alpha_e_dl,verbose)\n\nBuilds the electric only DDA matrix A=I-Galpha with dimensionless positions kr (2D array of size Ntimes3) and dimensionless polarizabilities alpha_e_dl (see format rules in the Alphas module documentation). Returns 3Ntimes 3N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)\n\nBuilds the electric and magnetic CEMD matrix A=I-Galpha with dimensionless positions kr (2D array of size Ntimes 3) and dimensionless electric and magnetic polarizabilities alpha_e_dl and  alpha_m_dl (see format rules in the Alphas module documentation). Returns the 6Ntimes 6N complex CEMD matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_dl,verbose)\n\nBuilds the electric and magnetic CEMD matrix A=I-Galpha with dimensionless positions kr (two dimensional arrays of size Ntimes 3) and dimensionless polarizability alpha_dl (see format rules in the Alphas module documentation). Return 6Ntimes 6N complex DDA matrix\n\n\n\n\n\n","category":"method"},{"location":"example_PS_sphere/#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere","page":"PS Sphere","title":"Total and Differential Scattering Cross Sections of a Polystyrene Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This example aims to teach the user how to use CEMD.jl in only electric mode. For this we will compute the total and differential scattering cross section of a polystyrene (PS) sphere with a radius of 500nm in water. We will then compare it with Mie theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Be careful: using the electric DDA for solving this type of problems is not optimal at all (perhaps too slow and not accurate enough). The sizes and refractive indices used in this example make the problem converge reasonably well (see last section) and is then a nice figure of merit for this software. If you need to solve the light scattering problem of a sphere, it is better to  directly use Mie theory. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you don't know what a DDA problem is, please first have a look to the Theory pdf.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you want to run this example, copy it or download it from the GitHub repository (example_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"julia example_PS_sphere.jl\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you can, it is recommanded to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra and Lebedev are used to perform integrals on the surface of a sphere (Lebedev.jl).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing Lebedev\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_PS_sphere/#Discretizing-the-Sphere","page":"PS Sphere","title":"Discretizing the Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We need to start modelizing our particle in water. For, this we start by defining the parameters of the simulation. PS has a refractive index of 1.59 (we consider no absorption, so no imaginary part). For water, it is 1.33. We can set the dielectric constant of the particle eps and of the medium eps_h using epsilon=n^2. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"##################### Parameters ########################################\n#radius (in nm)\na=250\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute (in nm)\nN_lambda=10\nlambda_min=1000\nlambda_max=1100\n#wavelengths to compute\nlambdas0=LinRange(lambda_min,lambda_max,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"lambdas0 are the wavelengths for which we want to compute the scattering cross section (here between 1000 and 1100nm). We directly compute the wavelength in the host medium by dividing the vacuum wavelength by the refractive index of the host medium. Note that we always use the wavenumber in the host medium in the software.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then discretize the sphere in small cubes using Geometries.discretize_sphere. The first parameter is the radius of the sphere and the second is the number of cubes to place in the diameter of the sphere (it will set the total number of cubes of the discretized sphere).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If N_d is the number of cubes in the discretized sphere, this function returns a N_dtimes 4 array latt, that contains the coordinates of the center of each cube, as well as its filling fraction. If the cube is in the bulk, the filling fractions is 1. If it is on the surface, the filling fraction can be smaller than 1, depending on volume fraction of the sphere really inside the sphere. It also returns dx, which is the length of the edges of all the cubes.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here for instance, the number of cubes in the discretized sphere is N_d=720.","category":"page"},{"location":"example_PS_sphere/#Computing-the-Polarizabilities","page":"PS Sphere","title":"Computing the Polarizabilities","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Now that the sphere is discretized, we need to assign to every cube a polarizability. This polarizability is wavelength dependent and we need to create an array to store the results of the cross section calculations for each wavelength. For this, we use:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#getting number of cubes in the discretized sphere\nn=length(latt[:,1])\n#create an array to store results\nres=zeros(Float64,N_lambda,3)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then open a loop and compute the polarizability of each cube as follows:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#solves DDA problem for each wavelength\nfor i=1:N_lambda\n    #wavenumber in medium\n    knorm=2*pi/lambdas[i]\n    #computes polarizability for each dipoles using effective dielectric constant \n    alpha=zeros(ComplexF64,n)\n    for j=1:n\n        eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n        alpha[j]=Alphas.alpha_radiative(Alphas.alpha0_cube(dx,eps_eff,eps_h),knorm)\n    end","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here, we first compute the wavenumber in the medium and then, using the second loop, assign a polarizability to each cube. Alphas.alpha0_cube computes the quasistatic polarizability of a cube. Here, we use eps_eff, which is the filling fraction-ponderated mean between the dielectric constant inside and outside the medium. Then, we need to apply the radiative correction to the polarizability using Alphas.alpha_radiative. This last function also renormalizes the polarizability from units of volume to a dimensionless quantity. We need this because the functions to solve the DDA problem requires dimensionless inputs. See the home page and the Theory pdf for more information.","category":"page"},{"location":"example_PS_sphere/#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections","page":"PS Sphere","title":"Solving the DDA Problem and Computing the Total Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Before solving the DDA problem, we need to choose an input field. We will take a x-polarized plane wave propagating along the positive z axis. For this, we use inputFields.plane_wave_e. This functions takes the dimensionless positions kr of the center of the cubes (i.e. the wavenumber times the coordinates array) and outputs a N_dtimes 3 array that represent the input field on each of the dipoles.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes input_field, an x-polarized plane-wave propagating along z\n    input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can now solve the DDA problem between all the dipoles using DDACore.solve_DDA_e:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #solves DDA\n    e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"The solver is set to \"CPU\", that means that the system of linear equations is going to be solved using the CPU and LAPACK, called from Julia. This outputs a N_dtimes 3 complex array containing the incident field on each dipole. This incident field can the be used to compute the extinction, absorption and scattering total cross sections (sigma_ext sigma_abs sigma_sca) by calling PostProcessing.compute_cross_sections_e.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes cross section and save it in folder\n    res[i,1:end]=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\nend","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This function is just returning sigma_ext sigma_abs sigma_sca in a float array. This result is directly saved in res, that we created before.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It is now possible to plot the normalized scattering cross section (Q_sca=sigma_scapi a^2) as a function of the vacuum wavelength divided by the radius lambda_0 a. To check that the result we obtain is correct, we compare with Mie theory (using the MieCoeff module). We also plot the error (Q_ext-Q_abs-Q_abs)Q_ext to check that the optical theorem, i.e. sigma_ext=sigma_abs+sigma_sca is well fulfilled. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#scattering cross section from the Mie theory\nres_mie=MieCoeff.mie_scattering.(2 .*pi./lambdas*a,eps,eps_h;cutoff=50)\n\n#plotting the cross sections using matplotlib\nfig1,ax1=plt.subplots(2,sharex=true)\n#sets axis labels\nax1[1].set_ylabel(L\"Q_{sca}\")\nax1[2].set_ylabel(L\"(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}\")\nax1[2].set_xlabel(L\"\\lambda_0/a\")\n#plot\ncst=pi*a^2\nax1[1].plot(lambdas0./a,res[:,3]./cst,color=\"black\",label=\"DDA, N=\"*string(n),marker=\"o\")\nax1[1].plot(lambdas0./a,res_mie,color=\"red\",label=\"Mie\",marker=\"o\")\nax1[2].plot(lambdas0./a,(res[:,1].-res[:,2].-res[:,3])./res[:,1],color=\"black\",marker=\"o\")\n#legend and save\nax1[1].legend()\nplt.tight_layout()\nfig1.savefig(\"Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This is what we get:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We see that the DDA cross section is reasonably close to the Mie theory one and that the energy is correctly conserved. For more information, a small convergence study is shown in the last section of this example (without code).","category":"page"},{"location":"example_PS_sphere/#Computing-the-Differential-Scattering-Cross-Sections","page":"PS Sphere","title":"Computing the Differential Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"In this part of the example, we want to compute the differential scattering cross section in the y-z plane for the same sphere (we fix here the wavelength to be lambdas[1], i.e. 1000nm in vacuum). To start, we just solve the DDA problem and compute cross sections as we did previously.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes polarizability for each dipoles using effective dielectric constant \nknorm=2*pi/lambdas[1]\nalpha=zeros(ComplexF64,n)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    global  alpha[j]=Alphas.alpha_radiative(Alphas.alpha0_cube(dx,eps_eff,eps_h),knorm)\nend\n\n#computes input_field, an x-polarized plane-wave propagating along z\ninput_field=InputFields.plane_wave_e(knorm*latt[:,1:3])\n#solves DDA\ne_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")\n#computes cross section\ncs=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Then, we define a array of angle thetas in order to generate a uniform sampling ur of the units vectors in the y-z plane.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#sampling direction an plotting \nthetas=LinRange(0,2*pi,100)\nur=zeros(100,3)\nur[:,3]=cos.(thetas)\nur[:,2]=sin.(thetas)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"using this array of directions, we can compute the differential cross section for all of them using PostProcessing.diff_scattering_cross_section_e. This takes the same positional arguments as PostProcessing.compute_cross_sections_e, but just adding the array of directions. It outputs an array containing the differential scattering cross section in all the directions contained in ur.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes differential cross section\nres=PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,ur)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can plot it in polar coordinates.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#plotting\nfig2=plt.figure()\nax2 = fig2.add_subplot(projection=\"polar\")\nax2.set_title(L\"log(d Q_{sca}/ d \\Omega)\")\nax2.plot(thetas,log10.(res/pi/(a^2)),label=\"y-z plane\")\nplt.tight_layout()\nfig2.savefig(\"diff_Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/diff_Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"On this plot, the input wave is coming from the left side. We see that most of the light is forward scattered. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"For a sanity check, we can try to integrate the differential scattering cross section on the unit sphere using Lebedev.jl and compare with the total scattering cross section. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#Compare total scattering cross section and integral of the differential one\nx,y,z,w = lebedev_by_order(13)\ncsca_int=4 * pi * dot(w,PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,[x y z]))\nprintln(cs[3],\" : \",csca_int)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It outputs","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"50042.00684959106 : 50042.00684909766\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"showing, that they are the same within 10^-12 precision.","category":"page"},{"location":"example_PS_sphere/#A-Note-on-Convergence","page":"PS Sphere","title":"A Note on Convergence","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"As seen in the previous sections, the scattering cross section obtained with N=720 cubes/dipoles don't match perfectly with the Mie theory solution (a bit more than 1%). But what happens if we change the number of cubes? We repeated the calculations of the total scattering cross section but with several number of dipoles (from 117 to 9549). Here are the results: ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/test_conv.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"What we see is that the error starts to be much smaller for numbers of dipoles bigger than 2295. The example of the PS sphere works quite well, but be careful, this doesn't mean that it will converge like that for every type of spheres. If you want to do that with different types of material or object, check the convergence!. Recall also that DDA is not the best method to solve light scattering problems by a sphere. If you don't really need it, perhaps you prefer to use Mie Theory.","category":"page"},{"location":"example_PS_sphere/#Generalization-to-Other-Geometries","page":"PS Sphere","title":"Generalization to Other Geometries","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"The code described above can be easily modified to deal with another geometry. For instance, the examples folder (in the same folder as the example exposed above) contains an example of the scattering of a plane wave (x-polarized and propagating along the z-axis) by a cube of dielectric constant ε = (1.6 + 0.01i) placed in vacuum. The dimensionless edge length of the cube is kD = 0.1, the same as the one presented in Yurkin, M. A. and Kahnert, M., “Light scattering by a cube: Accuracy limits of the discrete dipole approximation and the T-matrix method”, Journal of Quantitative Spectroscopy and Radiative Transfer, vol. 123, pp. 176–183, 2013. We found that the scattering efficiency retrieved from our code has a precision within 0.02% of the value given in the paper cited above.","category":"page"},{"location":"example_ldos_silver_np/#Local-density-of-states-for-a-metallic-nanoparticle","page":"LDOS Silver Particle","title":"Local density of states for a metallic nanoparticle","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This example aims to show how to use other utilities such as the local density of states (LDOS) by reproducing the results of R. Carminati et. al., Opt. Comm. 261, 368 (2006). The system under study is a silver particle of radius 5 nm around its plasmon-resonance frequency (wavelength lambda = 354 nm) and at out-of-resonance (lambda = 612 nm). The numerical projected LDOS (see the Theory pdf is then compared with the analytical results derived in the that manuscript.  ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"If you want to run this example, copy it or download it on the github (example_ldos_silver_np.jl) and run it using ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"julia example_ldos_silver_np.jl\n","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use PyCall, because we will use the python matplotlib library in order to plot the results.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_ldos_silver_np/#Defining-analytical-solutions-from-R.-Carminati-et.-al.,-Opt.-Comm.-261,-368-(2006)","page":"LDOS Silver Particle","title":"Defining analytical solutions from R. Carminati et. al., Opt. Comm. 261, 368 (2006)","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let us first define the analytical solution of the LDOS, that takes as inputs the dimensionless distance kz and polarizability alp_dl, and the outputs are the projected LDOS along the z- and x-axis. By definition, the silver nanoparticle will be placed at the origin of the coordinate system, and the LDOS is measured along the z-axis.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# analytic solution R. Carminati et. al., Opt. Comm. 261, 368 (2006)\nfunction ldos_analytic(kz, alp_dl)\n    ldos_z = 1 + 6*imag(alp_dl*exp(2*im*kz)*(-1/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    ldos_x = 1 + 3/2*imag(alp_dl*exp(2*im*kz)*(1/kz^2 + 2*im/kz^3 - 3/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    return ldos_z, ldos_x\nend\nfunction nonrad_ldos_analytic_shortdistance(kz, alp_dl)\n    ldos_z = 6*(imag(alp_dl) - 2/3*abs2(alp_dl))*(1/kz^4 + 1/kz^6) \n    ldos_x = 3/2*(imag(alp_dl) - 2/3*abs2(alp_dl))*(1/kz^2 - 1/kz^4 + 1/kz^6) \n    return ldos_z, ldos_x\nend\nfunction rad_ldos_analytic_shortdistance(kz, alp_dl)\n    ldos_z = 1 + 4*abs2(alp_dl)*(1/kz^4 + 1/kz^6) + 4*real(alp_dl)/kz^3\n    ldos_x = 1 + abs2(alp_dl)*(-1/kz^4 + 1/kz^6) - 2*real(alp_dl)/kz^3\n    return ldos_z, ldos_x\nend","category":"page"},{"location":"example_ldos_silver_np/#Setting-physical-properties","page":"LDOS Silver Particle","title":"Setting physical properties","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Now let us set the parameters of the system, as well as the variables in which the LDOS will be stored.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# physical properties\n# particle radius\na = 5\n# wavelengths\nlamb = [612, 354] \n# dielectric constant of the particle\neps=[-15.04 + im*1.02, -2.03 + im*0.6] \n# distance between particle and dipole \nnz = 91 \nz = LinRange(10,100,nz)\n\n# variables to store the calculations\nldos_z = zeros(nz,2) \nldos_x = zeros(nz,2)\nldos_z_analytic = zeros(nz,2) \nldos_x_analytic = zeros(nz,2)\nrad_ldos_z = zeros(nz,2) \nrad_ldos_x = zeros(nz,2)\nrad_ldos_z_analytic_shortdistance = zeros(nz,2) \nrad_ldos_x_analytic_shortdistance = zeros(nz,2)\nnonrad_ldos_z = zeros(nz,2) \nnonrad_ldos_x = zeros(nz,2)\nnonrad_ldos_z_analytic_shortdistance = zeros(nz,2) \nnonrad_ldos_x_analytic_shortdistance = zeros(nz,2)","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"The values of the permittivity are taken directly from Carminati et al. manuscript, that correspond with the permittivity at the specific wavelengths, as can be checked in E.W. Palik, Handbook of Optical Constants of Solids, Academic Press, San Diego, 1985 for bulk silver. ","category":"page"},{"location":"example_ldos_silver_np/#Computing-the-LDOS","page":"LDOS Silver Particle","title":"Computing the LDOS","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"We can loop through distances and wavelenghts to compute the LDOS as follows:","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# ldos calculation at both wavelengths and all distances\nfor i=1:2 # loop in wavelength\n    # wavevector\n    knorm = 2*pi/lamb[i] \n    # permittivity\n    eps_i = eps[i] \n    # calculation of the polarizability\n    alp_0 = Alphas.alpha0_sphere(a,eps_i,1) # static polarizability\n    alp_e_dl = Alphas.alpha_radiative(alp_0,knorm) # dimensionless polarizability with radiative corrections\n    for j=1:nz # distances loop\n        # distance\n        z_j = z[j] \n        # normalized distance\n        kz = knorm*z_j\n        # normalized position of the particle (at the origin of coordinates) \n        kr = zeros(1,3) \n        # normalized position of the diple (z-component at kz)\n        krd = zeros(1,3) \n        krd[3] = kz\n        # analytic ldos\n        global ldos_z_analytic[j,i], ldos_x_analytic[j,i] =  ldos_analytic(kz, alp_e_dl) \n        # numerical ldos\n        Ainv = DDACore.solve_DDA_e(kr,alp_e_dl) # calculation inverse dda matrix\n        global ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 3) # ldos z-axis\n        global ldos_x[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 1) # ldos x-axis\n\n        # analytic ldos at short distances for radiative and non radiative components\n        global rad_ldos_z_analytic_shortdistance[j,i], rad_ldos_x_analytic_shortdistance[j,i] =  rad_ldos_analytic_shortdistance(kz, alp_e_dl)\n        global nonrad_ldos_z_analytic_shortdistance[j,i], nonrad_ldos_x_analytic_shortdistance[j,i] =  nonrad_ldos_analytic_shortdistance(kz, alp_e_dl)\n\n        # numerical ldos for radiative and non radiative components\n        dip_z = zeros(3)\n        dip_z[3] = 1\n        dipole_field = InputFields.point_dipole_e(kr, krd[:], dip_z) # field of the point dipole with dipole moment \"dip_z\"\n        phi_inc = DDACore.solve_DDA_e(kr,alp_e_dl;input_field=dipole_field)     # incident field at the silver particle \n        dipole_moment = PostProcessing.compute_dipole_moment(alp_e_dl,phi_inc) # dipole moment at the silver particle\n        global rad_ldos_z[j,i] = PostProcessing.rad_ldos_e(kr,krd,dipole_moment,dip_z)          # radiative ldos z-axis\n        global nonrad_ldos_z[j,i] = PostProcessing.nonrad_ldos_e(dipole_moment,phi_inc,dip_z)   # non-radiative ldos z-axis\n\n        dip_x = zeros(3)\n        dip_x[1] = 1\n        dipole_field = InputFields.point_dipole_e(kr, krd[:], dip_x) # field of the point dipole with dipole moment \"dip_x\"\n        phi_inc = DDACore.solve_DDA_e(kr,alp_e_dl;input_field=dipole_field)     # incident field at the silver particle \n        dipole_moment = PostProcessing.compute_dipole_moment(alp_e_dl,phi_inc) # dipole moment at the silver particle\n        global rad_ldos_x[j,i] = PostProcessing.rad_ldos_e(kr,krd,dipole_moment,dip_x)          # radiative ldos x-axis\n        global nonrad_ldos_x[j,i] = PostProcessing.nonrad_ldos_e(dipole_moment,phi_inc,dip_x)   # non-radiative ldos x-axis\n\n    end\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"The selection of the projection of the LDOS is done by the dip argument. It is also possible to pass an array as an argument, defining the dipole moment of the testing dipolar source as","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"dip_vec = zeros(3)\ndip_vec[3] = 1 \nglobal ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = dip_vec) # ldos z-axis","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This way of calculating the projection along the z-axis would lead to the same result. Also, dip could be any three (or six for electric and magnetic dipoles) dimensional vector.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"It is now possible to plot the LDOS, comparing the numerical and analytical calculations. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# plot ldos\npas = 5 \nfor ind_l = 1:2\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSx lambda = \"*string(Int(lamb[ind_l]))*\" nm\")\n    axs.plot(z,ldos_x_analytic[:,ind_l],\"--b\",label=\"total analytic\")\n    axs.plot(z,rad_ldos_x_analytic_shortdistance[:,ind_l],\"--r\",label=\"radiative analytic\")\n    axs.plot(z,nonrad_ldos_x_analytic_shortdistance[:,ind_l],\"--g\",label=\"non radiative analytic\")\n    axs.plot(z[1:pas:end],ldos_x[1:pas:end,ind_l],\"ob\",label=\"total DDA\")\n    axs.plot(z[1:pas:end],rad_ldos_x[1:pas:end,ind_l],\"or\",label=\"radiative DDA\")\n    axs.plot(z[1:pas:end],nonrad_ldos_x[1:pas:end,ind_l],\"og\",label=\"non radiative DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_x\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSx\"*string(Int(lamb[ind_l]))*\".svg\")\n\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSz lambda = \"*string(Int(lamb[ind_l]))*\" nm\")\n    axs.plot(z,ldos_z_analytic[:,ind_l],\"--b\",label=\"total analytic\")\n    axs.plot(z,rad_ldos_z_analytic_shortdistance[:,ind_l],\"--r\",label=\"radiative analytic\")\n    axs.plot(z,nonrad_ldos_z_analytic_shortdistance[:,ind_l],\"--g\",label=\"non radiative analytic\")\n    axs.plot(z[1:pas:end],ldos_z[1:pas:end,ind_l],\"ob\",label=\"total DDA\")\n    axs.plot(z[1:pas:end],rad_ldos_z[1:pas:end,ind_l],\"or\",label=\"radiative DDA\")\n    axs.plot(z[1:pas:end],nonrad_ldos_z[1:pas:end,ind_l],\"og\",label=\"non radiative DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_z\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSz\"*string(Int(lamb[ind_l]))*\".svg\")\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"In the following figures, we compare the analytical results with the numerical ones. There is a very good agreement among them.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx612.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz612.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Electromagentic-Forces-on-a-Polystyrene-Sphere-Induced-by-a-Gaussian-Beam","page":"Optical Trap","title":"Electromagentic Forces on a Polystyrene Sphere Induced by a Gaussian Beam","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"This example aims to illustrate how to calculate optical forces, as well as how to calculate the field of a Gaussian beam and its derivatives. Note that the derivatives are implemented as dimensionless. Thus, both the field and the derivatives would have the same units.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"The forces will be calculated along the three axes, x-, y- and z-axis. We consider a Gaussian beam focused at the origin of coordinates. The force is calculated as a function of the position of the PS particle center relative to the focal point of the beam. In order to avoid the re-inversion of the DDA matrix, the particle is fixed at the center of coordinates, while the focal point of the Gaussian Beam is moving.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"If you want to run this example, copy it or download it on the github (example_force_gaussbeam_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"julia example_force_gaussbeam_PS_spher.jl\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"It is recommended to run the code in parallel, using the --threads option. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Let us start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Discretizing-the-Sphere-and-polarizability","page":"Optical Trap","title":"Discretizing the Sphere and polarizability","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"We need to start modeling our particle in water. The parameters are the same as for example_PS_sphere.jl. Thus, please visit this example for more details.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"##################### Parameters ########################################\n#radius of the sphere (in this example, we work in microns)\na=0.25\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n##########################################################################\n\n#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)\nn=length(latt[:,1])\n\n# wavelength in the host medium (1 micron in vacuum)\nlamb = 1/sqrt(eps_h)\n# wavevector\nknorm=2*pi/lamb\n# normalized position of the dipoles\nkr = knorm*latt[:,1:3]\n\n#computes polarizability for each dipoles using effective dielectric constant \nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    alpha[j]=Alphas.alpha_radiative(Alphas.alpha0_cube(dx,eps_eff,eps_h),knorm)\nend\n# calculation of the inverse DDA matrix\nAinv = DDACore.solve_DDA_e(kr,alpha)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Notice that in this example DDACore.solve_DDA_e has no input_field argument. Then, the output is the inverse DDA matrix. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Setting-incoming-field-and-particle-position","page":"Optical Trap","title":"Setting incoming field and particle position","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"As an incoming field, we will use a Gaussian Beam with beam waist radius bw_0 = lambda2, that in adimensional units is knorm*bw_0 = pi. Also, the forces will be calculated along the three axes, between [-2\\lambda, 2\\lambda], discretizing the space in 51 points. For convenience, it is better to use an odd number of points in order to take the 0.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# parameters of the Gaussian Beam\n# beam waist radius is set to lamb/2\nkbw0 = pi # (2*pi/lambda)*(lamb/2)\n\n# discretization of the position of the particle\nndis = 51 # odd number in order to mesh the \"0\" position\ndis = LinRange(-2*lamb,2*lamb,ndis)\n# variable where the force will be stored\nforce = zeros(ndis,3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-the-forces","page":"Optical Trap","title":"Calculating the forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Finally, we can loop on positions and compute the forces as follows:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# loop on positions\n# note that, instead of moving the particle (and avoiding to recalculate the inverse DDA matrix), the position of the focus \n# of the Gaussian beam is changed.\nfor i=1:ndis \n    # forces along the x-axis \n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [dis[i] 0 0])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,1] = sum(fx)\n\n    # forces along the y-axis \n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [0 dis[i] 0])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,2] = sum(fy)\n\n    # forces along the z-axis\n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [0 0 dis[i]])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces\n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,3] = sum(fz)\nend","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Expressing-Forces-in-Newtons","page":"Optical Trap","title":"Expressing Forces in Newtons","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"The output of the function for the forces has the same unit as the square of the input field. In order to express the forces in Newtons it is necessary to multiply by a factor epsilon_0epsilon_h 4 pi k^2 (a factor 4 pi k^3 that accounts for the adimensionality of the polarizability and a factor k since the spatial derivatives of the Green function and of the external field are adimensional), where the field, epsilon_0 and k must be in SI units. Also, in the calculation of the Gaussian beam field we have set E_0 = 1 (value by default), and the force must be scaled according to the intensity of the beam. Thus, assuming that our laser source has a power of P = 10 mW, we can proceed as follows.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"First, for simplicity, we consider that the intensity distribution at the focus also follows a Gaussian distribution, ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"I(xyz=0) = I_0 e^-2fracx^2 + y^2bw_0^2 ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"with ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"I_0 = dfrac12c epsilon_0epsilon_h E_0^2 ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"being c the speed of light in the medium. Under this approximation (not totally accurate since the beam is tight focused), the power of the beam can be calculated as the surface integral of the intensity at the focal plane","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"P = I_0 int_z=0 e^-2fracx^2 + y^2bw^2 = I_0 pi dfracbw_0^22","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Thus, to convert the forces units into Newtons, the calculated forces must be multiplied by ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"epsilon_0epsilon_h 4 pi k^2 E_0^2 = dfrac16 Pc (kwb_0)^2","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"For the Gaussian beams implemented in the library (gaussian, hermite and legendre beams), there is a function in the Force module called Forces.force_factor_gaussianbeams that calculates this proportionality factor. Hence, we can use it as follows:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# converts forces in Newtons\n# laser power (10 mW)\npower = 10e-3\nfactor = Forces.force_factor_gaussianbeams(kbw0,power,eps_h)\n# force in Newtons\nforce = force*factor","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-Stiffness","page":"Optical Trap","title":"Calculating Stiffness","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Since the Gaussian beam is going to trap the particle, the forces around the equilibrium position can be approximated by a linear model. The depth of the trap can be characterized by the stiffness along the different axes, i.e. a simple spring model. Hence, to estimate the stiffness, a linear fit can be done.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# calculation of the stiffness of the trap by a linear fit around the zero force position\n# for kx and ky, we directly assume that the zero force position is at the minimum of the \"dis\" array (at dis = 0)\n# find the position of the minimum\nval, ind_min_xy = findmin(abs.(dis))\n# calculation of the stiffness along the x- and y-axis\nkx = -(force[ind_min_xy+1,1]-force[ind_min_xy-1,1])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\nky = -(force[ind_min_xy+1,2]-force[ind_min_xy-1,2])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\n# for kz the minimum is found as the first minimum along the z-axis (the minimum is not at \"z=0\")\nind_min_z = ind_min_xy\nwhile abs(force[ind_min_z,3]) > abs(force[ind_min_z+1,3])\n    min_z = ind_min_z + 1\n    global ind_min_z = min_z\nend\n# calculation of the stiffness along the z-axis\nkz = -(force[ind_min_z+1,3]-force[ind_min_z-1,3])/(dis[ind_min_z+1] - dis[ind_min_z-1])\n# linear calculation of for the position of the minimum\nzmin = dis[ind_min_z] + force[ind_min_z,3]/kz\n# shorter array for plotting the linear approximation of the forces\ndis_short = LinRange(-lamb/4,lamb/4,ndis)\n# linear approximation of the force around the zero\nfx_lin = -kx*dis_short\nfy_lin = -ky*dis_short\nfz_lin = -kz*(dis_short)\n# rounding the value of the stiffness for the legend\nkx = round(kx*1e6,sigdigits=3)\nky = round(ky*1e6,sigdigits=3)\nkz = round(kz*1e6,sigdigits=3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Plotting-Forces","page":"Optical Trap","title":"Plotting Forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Once the forces and the stiffness are calculated, they can be plotted using the following lines:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# plotting results\nfig, axs = plt.subplots()\naxs.set_title(L\"x-axis, bw_0 = \\lambda/2, P = 10 mW\")\naxs.plot(dis,force[:,1]*1e12,label=\"\")\naxs.plot(dis_short,fx_lin*1e12,\"--\",label=\"kx = \"*string(kx)*\" pN/um\")\naxs.set_xlabel(\"x (um)\")\naxs.set_ylabel(\"Fx (pN)\")\naxs.legend()\nfig.savefig(\"fx.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"y-axis,bw_0 = \\lambda/2, P = 10 mW\")\naxs.plot(dis,force[:,2]*1e12)\naxs.plot(dis_short,fy_lin*1e12,\"--\",label=\"ky = \"*string(ky)*\" pN/um\")\naxs.set_xlabel(\"y (um)\")\naxs.set_ylabel(\"Fy (pN)\")\naxs.legend()\nfig.savefig(\"fy.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"z-axis, bw_0 = \\lambda/2, P = 10 mW\")\naxs.plot(dis,force[:,3]*1e12)\naxs.plot((dis_short .+ zmin),fz_lin*1e12,\"--\",label=\"kz = \"*string(kz)*\" pN/um\")\naxs.plot(dis,force[:,3]*0,\"k--\")\naxs.set_xlabel(\"z (um)\")\naxs.set_ylabel(\"Fz (pN)\")\naxs.legend()\nfig.savefig(\"fz.svg\")\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fx.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fy.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fz.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Here, x,y and z in the horizontal axis are the positions of the PS particle relative to the focal point of the beam.","category":"page"},{"location":"miecoeff/#Mie-Coefficients","page":"MieCoeff","title":"Mie Coefficients","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"MieCoeff is a small module for computing Mie Coefficients. It also contains some useful function to compute cross sections (scattering efficiencies) from the Mie theory. ","category":"page"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"Expressions are taken in Craig F. Bohren, Donald R. Huffman, Absorption and Scattering of Light by Small Particles (1998).","category":"page"},{"location":"miecoeff/#Functions-Documentation","page":"MieCoeff","title":"Functions Documentation","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_an(ka, eps, eps_h; mu=1, mu_h=1, n=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an","text":"mie_an(ka, eps, eps_h; mu=1, mu_h=1, n=1)\n\nComputes the n-th mie coefficient a_n of a sphere with size parameter ka,  dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. Returns a complex scalar.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_bn(ka, eps, eps_h; mu=1, mu_h=1, n=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn","text":"mie_bn(ka, eps, eps_h; mu=1, mu_h=1, n=1)\n\nComputes the n-th mie coefficient b_n of a sphere with size parameter ka,  dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. Returns a complex scalar. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_ab1(ka, eps, eps_h; mu=1, mu_h=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_ab1-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_ab1","text":"mie_ab1(ka, eps, eps_h; mu=1, mu_h=1)\n\nComputes the first mie coefficient a_1 and b_1 of a sphere with size parameter ka,  dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. Returns a tuple with two complex scalar, a_1 and b_1, respectively. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_scattering(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering","text":"mie_scattering(ka,eps,eps_h;mu=1, mu_h=1, cutoff=20)\n\nComputes the scattering efficiency Q_sca of a sphere with size parameter ka, dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. For this, we use the finite sum:\n\nQ_sca =frac2ka^2sum^textcutoff_n=1left(2n+1right)left(a_n^2+b_n^2right)\n\nwhere cutoff is set to 20 by default.\n\nReturns a float.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_extinction(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction","text":"mie_extinction(ka,eps,eps_h;cutoff=20)\n\nComputes the extinction efficiency Q_ext of a sphere with size parameter ka, dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. For this, we use the finite sum:\n\nQ_ext =frac2(ka)^2sum^textcutoff_n=1left(2n+1right)Releft(a_n+b_nright)\n\nwhere cutoff is set to 20 by default.\n\nReturns a float.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_absorption(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption","text":"mie_absorption(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)\n\nComputes the extinction efficiency Q_abs of a sphere with size parameter ka, dielectric permittivity eps and magnetic permeability mu, in a host medium with dielectric permittivity eps_h and magnetic permeability mu_h. For this, we use:\n\nQ_abs =Q_ext-Q_sca\n\nwhere corresponding sums are cut to cutoff which is set to 20 by default.\n\nReturns a float.\n\n\n\n\n\n","category":"method"},{"location":"forces/#Optical-Forces","page":"Forces","title":"Optical Forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"The Forces module allows to compute optical forces on electric and magnetic point dipoles with deterministic input fields. The list of functions is given below. Note that N is the number of dipoles in the system. ","category":"page"},{"location":"forces/#Functions-Documentation","page":"Forces","title":"Functions Documentation","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e","text":"force_e(kr,alpha_e_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric dipoles for deterministic input fields. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_h 4pik^2, taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 3 containing the external input field.\ndxe_0: 2D complex array of size Ntimes 3 containing the derivative with regard to the k*x argument of the external input field.\ndye_0: 2D complex array of size Ntimes 3 containing the derivative with regard to the k*y argument of the external input field.\ndze_0: 2D complex array of size Ntimes 3 containing the derivative with regard to the k*z argument of the external input field.\n\nOutputs\n\nfx: float array of Size N with the value of the force along the x-axis at each dipole.\nfy: float array of Size N with the value of the force along the y-axis at each dipole.\nfz: float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\n","category":"function"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m(kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0)","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e_m-NTuple{8, Any}","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e_m","text":"force_e_m(kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric and magnetic dipoles for deterministic input fields. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_h 4pik^2, taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 6 containing the external input field.\ndxe_0: 2D complex array of size Ntimes 6 containing the derivative with regard to the k*x argument of the external input field.\ndye_0: 2D complex array of size Ntimes 6 containing the derivative with regard to the k*y argument of the external input field.\ndze_0: 2D complex array of size Ntimes 6 containing the derivative with regard to the k*z argument of the external input field.\n\nOutputs\n\nfx: float array of Size N with the value of the force along the x-axis at each dipole.\nfy: float array of Size N with the value of the force along the y-axis at each dipole.\nfz: float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\n","category":"method"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m(kr,alpha_dl, Ainv, e_0, dxe_0, dye_0, dze_0)","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e_m-NTuple{7, Any}","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e_m","text":"force_e_m(kr,alpha_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nSame as force_e_m(knorm,kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_h 4pik^2,  taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\n\n\n\n\n","category":"method"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","text":"force_factor_gaussianbeams(kbw0,power,eps_h;n=0,m=0,,kind=\"hermite\", e0 = 1, paraxial=true, kmax = nothing, maxe=Int(1e4), int_size = 5)\n\nComputes the proportionality factor to get the forces in units of Newtons when the forces are calculated using the Gaussian beams (Hermite and Laguerre) implemented in the library.  By default, the factor is calculated for a Gaussian Beam in the paraxial approximation.\n\nArguments\n\nkbw0: float with the dimensionless beam waist radius (kw_0, where w_0 is the beam waist radius).\npower: float with the power of the beam.\neps_h: float with the relative permittivity of the host medium.\nn: non-negative integer with the radial order of the beam.\nm: integer with the azimuthal order of the beam.\ne0: float with the modulus of the electric field used in the calculation of the beam profile. \nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). By default set to \"hermite\".\nparaxial: boolean setting if the calculation is done in the paraxial approximation.\nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptative integral (see Cubature.jl for more details).\nint_size: size of the integration area in units of kbw0. For high-order beams this parameter should be adjusted.\n\nOutputs\n\nforce_factor: proportionality factor to get the forces in units of Newtons. \n\n\n\n\n\n","category":"function"},{"location":"geometries/#Geometries-library","page":"Geometries","title":"Geometries library","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"Geometries is a small module allowing to discretize primitives in small cubes that can be later used in the DDA. The two primitives that are proposed are a sphere and a cube. Note that the discretization of the sphere implements super sampling anti-aliasing (see Wikipedia page for anti-aliasing or the PS sphere example).","category":"page"},{"location":"geometries/#Functions-Documentation","page":"Geometries","title":"Functions Documentation","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_sphere","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","text":"discretize_sphere(a,N;N_sub=10)\n\nDiscretizes the volume of a sphere of radius a in small cubes of edge dx=2*a/N. N_sub is a parameter to set the super sampling anti-aliasing accuracy of the discretization. It is by default set to 10. Let N_d be the obtained number of cubes, the output is a tuple with an N_d times 4 array containing the 3D position of the centers of the cubes (first three entries) and their filling fraction (fourth entry), as well as the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"function"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_cube(L,N)","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube-Tuple{Any, Any}","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube","text":"discretize_cube(L,N)\n\nDiscretizes the volume of a cube of edge L in small cubes of edge dx=L/N. Let N_d be the obtained number of cubes, the output is a tuple with an N_d times 4 array containing the 3D position of the centers of the cubes (first three entries) and their filling fraction (fourth entry), as well as the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Post-Processing","page":"PostProcessing","title":"Post Processing","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The PostProcessing module allows you to process the results of a DDA/CEMD calculation. Mostly for:","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"Computing cross sections and emission patterns. \nComputing scattered fields.\nComputing local density of states (LDOS).","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The list of functions and a description of how to use them is given in the following section. In general N represents the number of dipoles.","category":"page"},{"location":"postprocessing/#Functions-List-and-Documentation","page":"PostProcessing","title":"Functions List and Documentation","text":"","category":"section"},{"location":"postprocessing/#Functions-for-Cross-Sections-and-Emission-Patterns","page":"PostProcessing","title":"Functions for Cross Sections and Emission Patterns","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e(knorm,kr,e_inc,alpha,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e","text":"compute_cross_sections_e(knorm,kr,e_inc,alpha_e_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric dipoles, illuminated by a plane wave. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wave number in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the total incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it must be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section. Cross sections are given in units of knorm^{-2}`.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric and magnetic dipoles, illuminated by a plane wave. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wave number in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the total incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfPhi_0=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section. Cross sections are given in units of knorm^{-2}`.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)\n\nSame as compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e","text":"diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric dipoles in direction(s) ur.\n\nArguments\n\nknorm: wave number in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the total incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it should be a plane wave\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the directions mathbfu_r where the diffrential scattering cross section is computed. Note that these directions vectors are normalized to 1 in the function.\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction. Cross sections are given in units of knorm^{-2}`.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric and magnetic dipoles in direction(s) ur.\n\nArguments\n\nknorm: wave number in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the total incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfPhi_0=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions mathbfu_r where the diffrential scattering cross section is computed. Note that these directions vectors are normalized to 1 in the function.\nverbose: whether to output pieces of information to the standard output during at runtime or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction. Cross sections are given in units of knorm^{-2}`.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)\n\nSame as diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e(kr,e_inc,alpha_e_dl,ur,krd,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e","text":"emission_pattern_e(kr,e_inc,alpha_e_dl,ur,krd,dip;verbose=true)\n\nComputes the emission pattern d P dOmega (differential power emitted in a given direction) of a system made out of electric dipoles in direction(s) of position(s) krf.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the total incident electric field mathbfE_i on each dipole. The user is required to first solve the DDA problem for e_inc in the presence of a point dipole source placed at krd.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions mathbfu_r where the diffrential scattering cross section is computed. Note that these directions vectors are normalized to 1 in the function.\nkrd : float vector of length 3 containing the dimensionless position of the point electric dipole source.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively) \n\nor complex array of size 3 with the components for the electric dipole moment.\n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in directions ur in units of the power emitted by the emitter P_0 without any scatterers.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m(kr,phi_inc,alpha_e_dl,alpha_m_dl,ur,krd,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m","text":"emission_pattern_e_m(kr,phi_inc,alpha_e_dl,alpha_m_dl,ur,krd,dip;verbose=true)\n\nComputes the emission pattern d P dOmega of a system made out of electric and magnetic dipoles in direction(s) of position(s) krf.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the total incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions mathbfu_r where the diffrential scattering cross section is computed. Note that these directions vectors are normalized to 1 in the function.\nkrd : float vector of length 3 containing the dimensionless position of the point electric and/or magnetic dipole source.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively and dip = 4,5,6 is a magnetic dipole along x,y,z respectively) \n\nor complex array of size 6 with the first 3 components for the electric dipole moment and the last 3 components for the magnetic dipole moment.\n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in directions ur in units of the power emitted by the emitter P_0 without any scatterers.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m(kr,phi_inc,alpha_dl,ur,krd,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.emission_pattern_e_m","text":"emission_pattern_e_m(kr,phi_inc,alpha_dl,ur,krd,dip;verbose=true)\n\nSame as emission_pattern_e_m(kr,phi_inc,alpha_e_dl,alpha_m_dl,ur,krd,dip;verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-Scattered-Fields","page":"PostProcessing","title":"Functions for Scattered Fields","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e(kr, alpha_e_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e","text":"function field_sca_e(kr, alpha_e_dl, e_inc, krf)\n\nComputes the scattered field from a system made out of electric dipoles. Note that the term e^ikrkr is retained, so krf has to be finite.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the total incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered electric and magnetic fields by the dipoles at every kmathbfr_f. Note that the term e^ikrkr is retained, so krf has to be finite.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf; verbose=true)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the total incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered electric and magnetic fields by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_dl, phi_inc, krf)\n\nSame as field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e(kr, alpha_e_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e","text":"function far_field_sca_e(kr,e_inc,alpha_e_dl,krf)\n\nComputes the scattered field from a system made out of electric dipoles in the far field approximation. Note that the term e^ikrkr is retained, so krf has to be finite.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f. Note that the term e^ikrkr is retained, so krf has to be finite.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_e_dl,alpha_m_dl,krf)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles in the far field approximation. Note that the term e^ikrkr is retained, so krf has to be finite.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f. Note that the term e^ikrkr is retained, so krf has to be finite.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_dl,krf)\n\nSame as far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-LDOS","page":"PostProcessing","title":"Functions for LDOS","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e","text":"ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing, verbose=true)\n\nIt Computes local density of states (LDOS) of a system made out of electric dipoles normalized by the LDOS in the host medium without scatterers. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively) \n\nor complex array of size 3 with the components for the electric dipole moment.  \n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS normalized by the LDOS in the host medium without scatterers.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true)\n\nComputes local density of states (LDOS) of a system made out of electric and magnetic dipoles normalized by the LDOS in the host medium without scatterers. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) CEMD matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively and dip = 4,5,6 is a magnetic dipole along x,y,z respectively) \n\nor complex array of size 6 with the first 3 components for the electric dipole moment and the last 3 components for the magnetic dipole moment. \n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS normalized by the LDOS in the host medium without scatterers.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing, verbose=true)\n\nSame as ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e(kr,krd,p,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e","text":"rad_ldos_e(kr,krd,p,dip;verbose=true)\n\nComputes the radiative part of the LDOS of a system of electric point dipoles scatterers normalized by the LDOS in the host medium without scatterers. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nkrd: float array of size 3 containing the dimentionless position kmathbfr_d where the radiative part of the LDOS is calculated.\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively) \n\nor complex array of size 3 with the components for the electric dipole moment.  \n\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nfloat containing the normalized (by the LDOS in the host medium without scatterers) radiative LDOS at the position krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m(kr,krd,p,m,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m","text":"rad_ldos_e_m(kr,krd,p,m,dip;verbose=true)\n\nComputes the radiative part of the LDOS of a system of electric and magnetic point dipoles scatterers normalized by the LDOS in the host medium without scatterers. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nkrd: float array of size 3 containing the dimentionless position kmathbfr_d where the LDOS is calculated.\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\nm: 2D complex array of sizeNdtimes 3 containing the magnetic dipole moments of the dipoles.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively and dip = 4,5,6 is a magnetic dipole along x,y,z respectively) \n\nor complex array of size 6 with the first 3 components for the electric dipole moment and the last 3 components for the magnetic dipole moment.  \n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nfloat containing the normalized (by the LDOS in the host medium without scatterers) radiative LDOS at the position krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e(p,e_inc,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e-Tuple{Any, Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e","text":"nonrad_ldos_e(p,e_inc,dip;verbose=true)\n\nComputes the non-radiative part of the LDOS of a system of electric point dipoles scatterers normalized by the LDOS in the host medium without scatterers. Note that the scattering problem has to be solved previously using a point dipole source as input field.\n\nArguments\n\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles. It has to be previously computed by one of the DDACore functions and compute_dipole_moment.\ne_inc: 2D complex array of size Ntimes 3 containing the total incident electric field mathbfE_i on each dipole. It has to be previously computed by one of the DDACore functions, setting the input field to be a point dipole source.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively) \n\nor complex array of size 3 with the components for the electric dipole moment.  \n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\nfloat array containing the normalized non-radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m(p,m,phi_inc,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m","text":"nonrad_ldos_e_m(p,m,phi_inc,dip;verbose=true)\n\nComputes the non-radiative part of the LDOS of a system of electric and magnetic point dipoles scatterers normalized by the LDOS in the host medium without scatterers. Note that the scattering problem has to be solved previously using a point dipole source as input field.\n\nArguments\n\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles. It has to be previously computed by one of the DDACore functions and compute_dipole_moment.\nm: 2D complex array of sizeNdtimes 3 containing the magnetic dipole moments of the dipoles. It has to be previously computed by one of the DDACore functions, setting the input field to be a point dipole source.\nphi_inc: 2D complex array of size Ntimes 6 containing the total incident electric and magnetic field mathbfPhi_i=(mathbfE_imathbfH_i) on each dipole.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively and dip = 4,5,6 is a magnetic dipole along x,y,z respectively) \n\nor complex array of size 6 with the first 3 components for the electric dipole moment and the last 3 components for the magnetic dipole moment.  \n\nverbose: whether to output pieces of information to the standard output at runtime or not. By default set to true.\n\nOutputs\n\n1D float array containing the normalized non-radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Utilities-Functions","page":"PostProcessing","title":"Utilities Functions","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment(alpha,phi_inc)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment-Tuple{Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment","text":"compute_dipole_moment(alpha,phi_inc)\n\nComputes the dipole moment (magnetic or electric) of a dipole with polarizability alpha under an incident field phi_inc. alpha can be:\n\na complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.poynting_vector(phi)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector-Tuple{Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector","text":"poynting_vector(phi)\n\nComputes the poynting vector of an electromagnetic field. Input is an electric and magnetic field phi(1D complex Array of length 6). Outputs a 1D float array of length 3 in units of electriqc field squared.\n\n\n\n\n\n","category":"method"},{"location":"green/#Green's-Tensors","page":"GreenTensors","title":"Green's Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"GreenTensors is a module aimed to compute the renormalized (dimensionless) electric and magnetic Green's tensors. To learn more about the renormalization and the expressions that are used, please see the Theory pdf.","category":"page"},{"location":"green/#Functions-Documentation","page":"GreenTensors","title":"Functions Documentation","text":"","category":"section"},{"location":"green/#Renormalized-Green's-Tensors","page":"GreenTensors","title":"Renormalized Green's Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","text":"G_e_renorm(kr1,kr2)\n\nComputes the renormalized (dimensionless) electric Green's tensor between two positions r1 and r2, where the inputs are the positions multiplied by the host medium wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","text":"G_m_renorm(kr1,kr2)\n\nComputes the renormalized (dimensionless) magnetic Green's tensor between two position r1 and r2, where the inputs are the positions multiplied by the host medium wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","text":"G_em_renorm(kr1,kr2)\n\nComputes the renormalized (dimensionless) electric and magnetic Green's tensors between two positions r1 and r2, where the inputs are the positions multiplied by the host medium wave number kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix (electric and magnetic Green's tensor respectively).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","text":"G_em_far_field_renorm(kr1,kr2)\n\nComputes the renormalized (dimensionless) electric and magnetic Green's in the far field approximation tensors between two positions r1 and r2, where the inputs are the positions multiplied by the host medium wave number kr1 and kr2.Note that is is only valid for kr_1kr_2 and kr_11. The outputs are two dimensionless 3x3 complex matrix (electric and magnetic Green's tensor respectively).\n\n\n\n\n\n","category":"function"},{"location":"green/#Derivatives-of-the-Renormalized-Green's-Tensors","page":"GreenTensors","title":"Derivatives of the Renormalized Green's Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","text":"dxG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) electric Green's tensor  with respect to the kx component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","text":"dyG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) electric Green's tensor  with respect to the ky component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","text":"dzG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) electric Green's tensor  with respect to the kz component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","text":"dxG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) magnetic Green's tensor  with respect to the kx component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","text":"dyG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) magnetic Green's tensor  with respect to the ky component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","text":"dzG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) magnetic Green's tensor  with respect to the kz component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","text":"dxG_em_renorm(kr1,kr2)\nComputes the derivative of the renormalized (dimensionless) electric and magnetic Green's tensors with respect to the `kx` component of `kr1` between two positions (multiplied by the host medium wavenumber)  `kr1` and `kr2`.\nThe output is a dimensionless 3x3 complex matrix (electric and magnetic Green's tensor respectively).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","text":"dyG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) electric and magnetic Green's tensors with respect to the ky component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix (electric and magnetic Green's tensor respectively).\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","text":"dzG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized (dimensionless) electric and magnetic Green's tensors with respect to the kz component of kr1 between two positions (multiplied by the host medium wavenumber)  kr1 and kr2. The output is a dimensionless 3x3 complex matrix (electric and magnetic Green's tensor respectively).\n\n\n\n\n\n","category":"function"},{"location":"green/#Utility-Functions","page":"GreenTensors","title":"Utility Functions","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","text":"denormalize_G_e(Ge,knorm)\n\nPasses from a dimensionless electric Green's tensor Ge to a Green's tensor with units of length⁻¹ by multiplying by a factor k(4pi). knorm is the wavenumber in the host medium k.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","text":"denormalize_G_m(Gm,knorm)\n\nPasses from a dimensionless magnetic Green's tensor Gm to a Green's tensor with units of length⁻² by multiplying by a factor k^2(4pi). knorm is the wavenumber in the host medium k.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Input-Fields","page":"InputFields","title":"Input Fields","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"This module allows to compute input fields. It also implements derivatives of some of them.","category":"page"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"See the Theory pdf to know more about the expression used to compute the input fields. In general N represents the number of input positions. ","category":"page"},{"location":"input_fields/#Functions-Documentation","page":"InputFields","title":"Functions Documentation","text":"","category":"section"},{"location":"input_fields/#Plane-Waves","page":"InputFields","title":"Plane Waves","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","text":"plane_wave_e(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes the electric field of a monochromatic plane wave evaluated at a set of dimensionless positions krf. khat is the direction of propagation and e0 is the polarization. The user is responsible for using physical inputs. krf is a Ntimes 3 float array.  The output is a Ntimes 3 complex array representing the electric field at each of the positions in the krf array.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","text":"plane_wave_e_m(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes the electric and magnetic fields of a monochromatic plane wave evaluated at a set of dimensionless positions krf. khat is the direction of propagation and e0 is the polarization. The user is responsible for using physical inputs. krf is a Ntimes 3 float array.  The output is a Ntimes 6 complex array representing the electric and magnetic fields at each of the positions in the krf array.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Point-Dipole-Sources","page":"InputFields","title":"Point Dipole Sources","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","text":"point_dipole_e(krf, krd, dip, e0_const=1)\n\nComputes the electric field emitted by an electric point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where the source is located.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively) \n\nor complex array of size 3 with the components for the electric dipole moment.  \n\ne0: float with the modulus of dip. \n\nOutputs\n\ne_dipole: 2D Ntimes 3 complex array with the electromagnetic field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","text":"point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the electric and magnetic fields emitted by an electric and/or magnetic point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where the source is located.\ndip: integer defining the dipole moment (dip = 1,2,3 is an electric dipole along x,y,z respectively and dip = 4,5,6 is a magnetic dipole along x,y,z respectively) \n\nor complex array of size 6 with the first 3 components for the electric dipole moment and the last 3 components for the magnetic dipole moment.  \n\ne0: float with the modulus of dip. \n\nOutputs\n\nphi_dipole: 2D Ntimes 6complex array with the electromagnetic fields at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Gaussian,-Hermite-Gaussian-and-Laguerre-Gaussian-Beams","page":"InputFields","title":"Gaussian, Hermite-Gaussian and Laguerre-Gaussian Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","text":"gaussian_beam_e(krf, kbw0,n,m; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electric field distribution of a Gaussian, Hermite-Gaussian and Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). By default, the Gaussian beam profile is calculated. For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkbw0: float with the dimensionless beam waist radius (komega_0, where omega_0 is the beam waist radius).\nn: int with the order of the beam.\nm: int with the degree of the beam.\nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). \ne0: float with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptive integral (see Cubature.jl for more details).\n\nOutputs\n\ne_gauss: 2D complex array of size Ntimes 3 with the value of the electric field at each positions.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","text":"gaussian_beam_e_m(krf, kbw0,n,m; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electromagnetic field distribution of a Gaussian, Hermite-Gaussian and Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). By default, the Gaussian beam profile is calculated. For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkbw0: float with the dimensionless beam waist radius (komega_0, where omega_0 is the beam waist radius).\nn: int with the order of the beam.\nm: int with the degree of the beam.\nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). \ne0: float with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptive integral (see Cubature.jl for more details).\n\nOutputs\n\nphi_gauss: 2D complex array of size Ntimes 6 with the value of the electric and magnetic fields at each positions.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Derivatives-of-the-Beams","page":"InputFields","title":"Derivatives of the Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","text":"d_plane_wave_e(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the spatial derivatives of an electric field generated with plane_wave_e (the arguments are the same as for plane_wave_e). Outputs three 2D arrays of size Ntimes 3 containing the electric field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","text":"d_plane_wave_e_m(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the spatial derivatives of an electromagnetic field generated with plane_wave_e_m (the arguments are the same as for plane_wave_e_m). Outputs three 2D arrays of size Ntimes 6 containing the electric and magnetic fields derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","text":"d_point_dipole_e(krf, krd, dip, e0=1)\n\nComputes the spatial derivatives of an electric field generated with point_dipole_e (the arguments are the same as for point_dipole_e). Outputs three 2D arrays of size Ntimes 3 containing the electric field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","text":"d_point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the spatial derivatives of an electromagnetic field generated with point_dipole_e_m (the arguments are the same as for point_dipole_e_m). Outputs three 2D arrays of size Ntimes 6 containing the electric and magnetic fields derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","text":"d_gaussian_beam_e(krf, kbw0; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the spatial derivatives of an electric field generated with gaussian_beam_e (the arguments are the same as for gaussian_beam_e_m). Outputs three 2D arrays of size Ntimes 3 containing the electric field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","text":"d_gaussian_beam_e_m(krf, kbw0; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the spatial derivatives of an electromagnetic field generated with gaussian_beam_e_m (the arguments are the same as for gaussian_beam_e_m). Outputs three 2D arrays of size Ntimes 6 containing the electric and magnetic field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledElectricMagneticDipoles.jl-v0.2.0","page":"Home","title":"CoupledElectricMagneticDipoles.jl v0.2.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation website for the coupled electric and magnetic dipoles (CEMD), or discrete dipoles approximation (DDA) method implementation in Julia! On this website, you will find all the descriptions of the functions implemented in this library. Please, read carefully the next sections to be ready to code with CoupledElectricMagneticDipoles.jl!","category":"page"},{"location":"#How-to-Use-this-Website-and-Learn-the-Library?","page":"Home","title":"How to Use this Website and Learn the Library?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website is divided into three parts. The first one is the home page, in which you will find all the information to install, run, and begin to use the package. You will find a theory section containing the definitions of the CEMD (DDA) problems and all the mathematical expressions that are used to implement the functions. The second part is dedicated to the 8 submodules of the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DDACore: Contains the functions to solve the coupled dipoles system of equations.\nAlphas: Small module to compute the polarizabilities.\nInputFields: Module with functions for input fields.\nPostProcessing: Module used to compute the scattering, absorption, and extinction cross sections, as well as the scattered field and local density of states (LDOS).\nForces: Module to compute optical forces between dipoles.\nGreenTensors: Contains functions to compute the electric and magnetic or both green tensors.\nGeometries: Small library to discretize some 3D primitives.\nMieCoeff: Contains functions to compute the Mie coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the example tab gives four examples of the use of this library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please have a look at the theory (next section) and the remaining of this page before starting. When ready, have a look at the examples. Note that functions that end in -_e are for systems made out of electric dipoles only and functions ending in -_e_m are for systems with both electric and magnetic dipoles.","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please read carefully the theory if you don't know about the CEMD (DDA) method. This pdf also provides you all the detailed expressions that are use to implement the library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p>You can download the theory document here: <a href=\"assets/supplementary_v_0_2_0.pdf\">Download PDF</a>.</p>","category":"page"},{"location":"#Installing-the-Library","page":"Home","title":"Installing the Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the library, type the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to install the package from local files (after downloading the files form the GitHub repository), extract the files from the zip file and set the parent directory as working directory. Then, you can install the library using","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add ./CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this, the package will be precompiled and the dependencies are going to be installed. Then, you will be able to import the library using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the library is installed and activated, we strongly recommend you try to run one example to see if everything works well. You can as well run unit tests (located in CoupledElectricMagneticDipoles/test/unit_tests.jl) to test if everything is well installed. ","category":"page"},{"location":"#Physical-Units","page":"Home","title":"Physical Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computers deal with numbers without units. Therefore, most of the inputs in the functions are dimensionless. For this, some renormalization may be needed. You will find all the details about units renormalization in the theory pdf, but the most used are for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Positions mathbfr (units of length L) are multiplied by the wave number k (units of L⁻¹), to get dimensionless positions kr.\nPolarizabilities have units of volume (units of length cube L³). We renormalize it by a factor k^34pi (units of L⁻³) to get dimensionless polarizabilities.\nMagnetic field is multiplied by the impedance Z in the medium. We then get a magnetic field that has the same units as the electric field. (E, H) becomes (E, ZH). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some functions do not use only dimensionless inputs. In all cases, this is the user's responsibility to send inputs that are coherent in terms of units. For example, it is important to input physical magnitudes with units of length all in the same units (don't put meter and micrometers together). It is recommended to look at the examples where the good practices are applied.","category":"page"},{"location":"#Running-the-Package-in-Parallel","page":"Home","title":"Running the Package in Parallel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solving the DDA system of equations can be done with two different parallel methods:","category":"page"},{"location":"","page":"Home","title":"Home","text":"With LAPACK LU decomposition on multiple CPUs (the number of BLAS threads is set to be equal to the number of Julia threads).\nWith LU decomposition on the GPU (CUDA), by offloading the system of equations to the GPU memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to know how to choose the solver, please have a look to the DDACore module documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In case you use the parallel CPU solver, just set the number of julia threads to use when you run the julia script, i.e. in this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --threads=8 foo.jl","category":"page"},{"location":"#Importing-the-Package-in-Python","page":"Home","title":"Importing the Package in Python","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is possible to run the package from Python. See the PyJulia package. Note that the example of the PS sphere has also been worked out in Python. The associated Python script can be found in the example folder.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite this software, please use: CoupledElectricMagneticDipoles.jl - Julia modules for coupled electric and magnetic dipoles method for light scattering, and optical forces in three dimensions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authors: Augustin Muster, Diego Romero Abujetas, Frank Scheffold, Luis S. Froufe-Pérez.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Journal: To be added upon publication.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To contact us, please do it through the GitHub repository.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Copyright (c) 2024 Augustin Muster, Diego R. Abujetas, Frank Scheffold and Luis Froufe-Pérez","category":"page"},{"location":"","page":"Home","title":"Home","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"}]
}
