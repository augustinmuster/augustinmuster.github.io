var documenterSearchIndex = {"docs":
[{"location":"example_yagi_uda/#Example:-Yagi-Uda-Antenna-Made-Out-of-Silicon-particles.","page":"Yagi-Uda Antenna","title":"Example: Yagi-Uda Antenna Made Out of Silicon particles.","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"In this example, we will simulate a Yagi-Uda antenna made out of small silicon spheres (like in Krasnok et al., Opt. Express 20, 20599-20604 (2012), click here for more information). For this, we will create a linear structure of small as follows: ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/YU_design.png\">","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"At the origin, we place a silicon sphere of 230nm called the reflector. After a bigger spacing of 355nm + 1800nm in which we will place the emitter (an oscillating dipole source aligned along the y-axis), we align on the z-axis 10 silicon spheres with a radius of 200nm, (center to center spacing: 400nm). We will then compute the emission pattern, in order to investigate the directionality of this antenna.  ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"We suppose that you already know the example of the PS sphere. So if you haven't had a look to it before, read it first. If you want to know about the electric and magnetic DDA problem, have a look at the theory as well.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If you want to run this example, copy it or download it on GitHub (example_yagi_uda.jl) and run it using ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"julia example_yagi_uda.jl\n","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If you can, it is recommended to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_yagi_uda/#Setting-the-Structure","page":"Yagi-Uda Antenna","title":"Setting the Structure","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"We will first start to model the structure of the antenna in an array 'r' containing the position of each of its component. But first, we need to imports the libraries. ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Then, we can set the parameters (size) of the antenna and build the structure.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"##################### Parameters ########################################\n#radius of the sphere (in μm)\na_refl=0.245 #reflector radius\na_dir=0.200 #director radius\nN_dir=10 #number of directors\n#dielectric constant of the particle\neps=12\n#wavelength (in μm) \nlambda=1.550\n##########################################################################\n\n#setting the structure\n#creates an array to contain the positions\nr=zeros(N_dir+1,3)\n\n#spacing between reflector and first director\nspacing_ref_dir=a_refl+0.355+0.800+a_dir\n#spacing between directors\nspacing_dirs=4*a_dir\n\n#sets the position of the directors (reflector is at the origin)\nfor i=2:N_dir+1\n    r[i,3]=spacing_ref_dir+(i-2)*spacing_dirs\nend\n\n#creates an array containing the radius of each sphere\nas=a_dir*ones(N_dir+1)\nas[1]=a_refl","category":"page"},{"location":"example_yagi_uda/#Modelling-silicon-particles","page":"Yagi-Uda Antenna","title":"Modelling silicon particles","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Now that we set the position of each of the antenna's components, we need to model their optical behavior. To do this, let's open a small parenthesis and try to model a sphere with a radius of 0.230 μm using only one electric and magnetic dipole per particle (no discretization like in the PS sphere example). For this, we set the electric and magnetic polarizabilities of the particles to be proportional to the two first Mie coefficients a_1 and b_1. For this, we use the MieCoeff module to get the Mie coefficient and to compare the scattering efficiency Q_sca of the sphere computed with only the first Mie coefficient and the truncated series (cut after 20 terms). ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#------------------modelling silicon particles---------------\n#parameter\nlambdas=LinRange(1.200,1.600,100)\nknorms=2*pi./lambdas\na=0.230\nka = knorms*a\neps=12\n#scattering cross sections\nmie_sca=MieCoeff.mie_scattering.(ka,eps,1,cutoff=20)\ndipole_sca=(6*pi)./knorms.^2 .*(abs2.(MieCoeff.mie_an.(ka, eps, 1, n=1)).+abs2.(MieCoeff.mie_bn.(ka, eps, 1, n=1)))\n#plotting\nfig1,ax1=plt.subplots()\nax1.set_xlabel(L\"\\lambda\\ (\\mu m)\")\nax1.set_ylabel(L\"Q_{sca}\")\nax1.plot(lambdas,mie_sca,color=\"black\",label=\"Mie\")\nax1.plot(lambdas,dipole_sca./(pi*a^2),color=\"red\",label=\"Dipoles\")\nfig1.savefig(\"mie_dipole_qsca.svg\")\n#------------------------------------------------------------","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If we plot it, we see that the scattering efficiency is well described by only the first Mie coefficients for wavelength bigger than 1.2 μm. From this, we conclude that later the polarizability of the components of the antenna can be computed using the alpha_mie_renorm function of the Alphas module.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/mie_dipole_qsca.svg\">","category":"page"},{"location":"example_yagi_uda/#Computing-Emission-Pattern","page":"Yagi-Uda Antenna","title":"Computing Emission Pattern","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"Now that we now how to model the particles, we can solve the DDA problem of the antenna as follow:","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"#computes the wavenumber\nknorm=2*pi/lambda\n#computes the polarizabilities using first mie coefficients\nalpha_e=zeros(ComplexF64,N_dir+1)\nalpha_m=zeros(ComplexF64,N_dir+1)\nfor i=1:N_dir+1 \n    alpha_e[i],alpha_m[i]=Alphas.alpha_e_m_mie(knorm*as[i],eps,1)\nend\n#computes the input input_field\ninput_field=InputFields.point_dipole_e_m(knorm*r,knorm*[0,0,0.355],2)\n\n#solves DDA electric and magnetic\nphi_inc=DDACore.solve_DDA_e_m(knorm*r,alpha_e,alpha_m,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"And since we know the incident fields, we can compute the emission pattern of the antenna by sampling directions in the y-z plane and computing the differential emitted power in these directions. Note that here we renormalize it by the power of the source dipole P_0 (or power_0 in the code).","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/diff_P.svg\">","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"After plotting the emission pattern in polar axes, we see that the antenna has like expected a pronounced directionality in the z direction.","category":"page"},{"location":"alphas/#Polarizabilities","page":"Alphas","title":"Polarizabilities","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"Alphas is a module to load polarizabilities. In this module, you will find functions to compute electric and magnetic polarizabilities of several objects. The modules also contains some functions to renormalize polarizabilities and to manage the multiple formats of the polarizabilities (dispatch). The list of functions as well as how to use them is given below. ","category":"page"},{"location":"alphas/#Format-of-the-polarizabilities-in-the-DDACore-and-PostProcessing-functions","page":"Alphas","title":"Format of the polarizabilities in the DDACore and PostProcessing functions","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"The functions of the DDACore and PostProcessing modules come with an automatic dispatch of the format of the polarizability. If we have N dipoles, it can be:","category":"page"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"a complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6","category":"page"},{"location":"alphas/#Functions-Documentation","page":"Alphas","title":"Functions Documentation","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped(lx,ly,lz,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped-NTuple{5, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped","text":"alpha0_parallelepiped(lx,ly,lz,eps,eps_h)\n\nComputes the quasistatic polarizability tensor of a parallelepiped of dimensions lx,ly,lz and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a 3times 3 float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_sphere(a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere","text":"alpha0_sphere(a,eps,eps_h)\n\nComputes the quasistatic polarizability of a sphere of radius a and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_volume(V,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume","text":"alpha0_volume(a,eps,eps_h)\n\nComputes the quasistatic polarizability of any object with volume V and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_radiative(alpha0,knorm)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative","text":"alpha_radiative(alpha0,knorm)\n\nApplies the radiative correction to the polarizability tensor or scalar alpha0 (with units of volume). Outputs a (3x3) complex dimensionless scalar or tensor computed as follow:\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie(ka,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie","text":"alpha_e_m_mie(vac_knorm,a,eps,eps_h)\n\nComputes the electric and magnetic polarizabilities from the mie coefficients a_1 and  b_1 of a particle with dimensionless radius ka, and of dielectric permittivity and magnetic permeability eps and mu, in a host medium with dielectric permittivity and magnetic permeability eps_h and mu_h. Outputs two dimensionless scalars that are respectively the electric and the magnetic polarizability.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e(alpha_e_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e","text":"dispatch_e(alpha_e_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i.\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i.\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nalpha_m_dl: magnetic polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\nalp_m: iterable magnetic polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i\n\nArguments\n\nalpha_dl: polarizability 6x6 tensor, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp: iterable polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.renorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha","text":"renorm_alpha(knorm,alpha)\n\nRenormalizes any polarizability alpha with units of volume in a dimensionless polarizability by multiplying by k^34pi. knorm is the wavenumber in the medium.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.denorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha","text":"denorm_alpha(knorm,alpha)\n\nDenormalizes any dimensionless polarizability alpha in a polarizability with units of volume by multiplying by 4pi k^3. knorm is the wavenumber in the medium.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#DDA-Core-Functionalities","page":"DDACore","title":"DDA Core Functionalities","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"DDACore is the modules allowing to solve CEMD problems (see the \"Theory\" section for definition of the problem). The problems can be solved either on the CPU (in parrallel with LAPACK) or on the GPU (With CUDA). The list of functions and how to use them is in the next section. Note that N denotes the number of point dipoles in the problem.","category":"page"},{"location":"ddacore/#Functions-List-and-Documentation","page":"DDACore","title":"Functions List and Documentation","text":"","category":"section"},{"location":"ddacore/#Main-Solver-Functions","page":"DDACore","title":"Main Solver Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e","text":"solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations under a given input field for a group of N only electric dipoles and returns the incident field on each of the dipoles. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 3, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If input_field=nothing, the output of the function will be the inverse of the DDA matrix.\nsolver: string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output informations to the standard output during running or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole. if input_field is a 2D array.\ne_inc: 3D complex array of size N_ftimes Ntimes 3 containing the incident electric field mathbfE_i on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size 3Ntimes 3, if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations with dimensionless inputs under a given input field for a group of N electric and magnetic dipoles and return the polarisations of every particle and incident field on every particle.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 3, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If input_field=nothing (default value), the output of the function will be the inverse of the DDA matrix.\nsolver:string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole, if input_field is a 2D array.\nphi_inc: 3D complex array of size N_ftimes Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size 6Ntimes 6N, if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"function solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nSame as solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#Utilities-Functions","page":"DDACore","title":"Utilities Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_system(A,b,solver,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_system-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_system","text":" solve_system(A,b,solver,verbose)\n\nSolves a system of equations of the type Ax=b using the method solver and returns x. x can be a 1D column vector or a 2D matrix. In this second case, the function is going to solve each column of the matrix as a different problem (without re-inverting A). The solver flag can be set to\n\nCPU: In this case, the system is solved using LAPACK on the CPU.\nGPU: In this case, the system is solved using CUSOLVE on the GPU (if available).\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e(kr,alpha_e_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e","text":" load_dda_matrix_e(kr,alpha_e_dl,verbose)\n\nBuilds the electric only DDA matrix A=I-Galpha with dimensionless positions kr (2D array of size Nx3) and dimensionless polarisabilities alpha_e_dl (see foramt rules in the Alphas module documentation). Returns 3Ntimes 3N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless positions kr (2D array of size Ntimes 3) and dimensionless electric and magnetic polarisabilities alpha_e_dl and  alpha_m_dl (see format rules in the Alphas module documentation). Returns the 6Ntimes 6N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_tensor,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_tensor,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless positions kr (two dimensional arrays of size Ntimes 3) and dimensionless polarisability alpha_tensor (see format rules in the Alphas module documentation). Return 6Ntimes 6N complex DDA matrix\n\n\n\n\n\n","category":"method"},{"location":"example_PS_sphere/#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere","page":"PS Sphere","title":"Total and Differential Scattering Cross Sections of a Polystyrene Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This example aims to teach the user how to use CEMD.jl in only electric mode. For this we will compute the total and differential scattering cross section of a polystyrene (PS) sphere with a radius of 500nm in water. We will then compare it with mie theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Be careful: using the electric DDA a for solving this type of problems is not optimal at all (way to slow and not accurate). The sizes and refractive indices used in this example make the problem converge reasonably well (see last section) and is then a nice figure of merit for this software. If you need to solve the light scattering of a sphere, it is better to use directly Mie theory. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you don't now what a DDA problem is, please first have a look to the theory part.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you want to run this example, copy it or download it on the github (example_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"julia example_PS_sphere.jl\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you can, it is recommanded to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra and Lebedev are used to perform integrals on the surface of a sphere (Lebedev.jl).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing Lebedev\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_PS_sphere/#Discretizing-the-Sphere","page":"PS Sphere","title":"Discretizing the Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We then need to start modelizing our particle in water. For, this we start by defining the parameters of the simulation. PS has a refractive index of 1.59 (we consider no absorption, so no imaginary part). For water, it is 1.33. We can then set the dielectric constant of the particle eps and of the medium eps_h using epsilon=n^2. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"##################### Parameters ########################################\n#radius (in nm)\na=250\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute (in nm)\nN_lambda=10\nlambda_min=1000\nlambda_max=1100\n#wavelengths to compute\nlambdas0=LinRange(lambda_min,lambda_max,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"lambdas0 are the wavelength for which we want to compute the scattering cross section (here between 1000 and 1100nm). We directly computes the wavelength in medium by dividing by the refractive index. Note that we always use the wavenumber in the medium in the software.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then discretize the sphere in small cubes using Geometries.discretize_sphere. The first parameter is the radius of the sphere and the second is the number of cubes to place in the diameter of the sphere (it will set the total number of cubes of the discretized sphere).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If N is the number of cubes in the discretized sphere, this function returns a Nx4 array latt, that contains the coordinates of the center of each cube, as well as its filling fraction (If the cube is in the bulk, the filling fractions is 1. If it is on the surface, the filling fraction can be smaller than 1, depending on volume fraction of the sphere really inside the sphere.). It also returns dx, which is the length of the edges of all the cubes.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here for instance, the number of cubes in the discretized sphere is N=720.","category":"page"},{"location":"example_PS_sphere/#Computing-the-Polarizabilities","page":"PS Sphere","title":"Computing the Polarizabilities","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Now that the sphere is discretized, we need to assign to every cube a polarizability. This polarizability is wavelength dependant and then we nee to create an array to store teh results of the cross section cslculations for each wavelength. For this, we use:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#getting number of cubes in the discretized sphere\nn=length(latt[:,1])\n#create an array to store results\nres=zeros(Float64,N_lambda,3)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then open a loop and computes the polarizability of each cube as follows:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#solves DDA problem for each wavelength\nfor i=1:N_lambda\n    #wavenumber in medium\n    knorm=2*pi/lambdas[i]\n    #computes polarizability for each dipoles using effective dielectric constant \n    alpha=zeros(ComplexF64,n,3,3)\n    for j=1:n\n        eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n        alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\n    end","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here, we first compute the wavenumber in the medium and then, using the second loop, assign a polarizability to each cube. Alphas.alpha0_parallelepiped computes the quasistatic polarizability tensor (a 3x3 complex matrix with units of volume) of a cube. Here, we use eps_eff, which is the filling fraction-ponderated mean between the dielectric constant inside and outside the medium. Then, we need to apply the radiative correction to the polarizability using Alphas.alpha_radiative. This last function also renormalize the polarizability from units of volume to no dimensions. We need this because the functions to solve the DDA problem require dimensionless inputs (see the home page and the theory part for more information!).","category":"page"},{"location":"example_PS_sphere/#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections","page":"PS Sphere","title":"Solving the DDA Problem and Computing the Total Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Before solving the DDA, problem, we need to choose an input field. We will take a x-polarized plane wave propagating along the positive z axis. For this, we use inputFields.plane_wave_e. This functions takes the dimensionless positions kr of the center of the cubes (i.e. the wavenumber times the coordinates array) and outputs a Nx3 array that represent the input field on each of the dipoles.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes input_field, an x-polarized plane-wave propagating along z\n    input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can now solve the DDA problem between all the dipoles using DDACore.solve_DDA_e:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #solves DDA\n    e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"The solver is set to \"CPU\", that means that the system of linear equations is going to be solved using the CPU and LAPACK, called from julia. This outputs a Nx3 complex array containing the incident field on each dipole. This incident field can the be used to compute the extinction, absorption and scattering total cross sections (sigma_ext sigma_abs sigma_sca) by calling PostProcessing.compute_cross_sections_e.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes cross section and save it in folder\n    res[i,1:end]=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\nend","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This function is just returning sigma_ext sigma_abs sigma_sca in a float array. This results is directly saved in res, that we created before.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It is now possible to plot the normalized scattering cross section (Q_sca=sigma_scapi a^2) as a function of the vacuum wavelength divided by the radius lambda_0 a. To check that the result we obtain is correct, we compare with Mie theory (using the MieCoeff module). We also plot the error (Q_ext-Q_abs-Q_abs)Q_ext to check tha t the optical theorem, i.e. sigma_ext=sigma_abs+sigma_sca is well fulfilled. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#scattering cross section from the Mie theory\nres_mie=MieCoeff.mie_scattering.(2 .*pi./lambdas*a,eps,eps_h;cutoff=50)\n\n#plotting the cross sections using matplotlib\nfig1,ax1=plt.subplots(2,sharex=true)\n#sets axis labels\nax1[1].set_ylabel(L\"Q_{sca}\")\nax1[2].set_ylabel(L\"(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}\")\nax1[2].set_xlabel(L\"\\lambda_0/a\")\n#plot\ncst=pi*a^2\nax1[1].plot(lambdas0./a,res[:,3]./cst,color=\"black\",label=\"DDA, N=\"*string(n),marker=\"o\")\nax1[1].plot(lambdas0./a,res_mie,color=\"red\",label=\"Mie\",marker=\"o\")\nax1[2].plot(lambdas0./a,(res[:,1].-res[:,2].-res[:,3])./res[:,1],color=\"black\",marker=\"o\")\n#legend and save\nax1[1].legend()\nplt.tight_layout()\nfig1.savefig(\"Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This is what we get:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We see that the DDA cross section is not exactly the same that the Mie one and that the energy is correctly conserved.. For more information, a small convergence study is shown in the last section of this example (without code).","category":"page"},{"location":"example_PS_sphere/#Computing-the-Differential-Scattering-Cross-Sections","page":"PS Sphere","title":"Computing the Differential Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"In this part of the example, we want to compute the differential scattering cross section in the y-z plane of the same sphere (we fix here the wavelength to be lambdas[1], i.e. 1000nm in vacuum). To start, we just solve the DDA problem and computes cross sections as we did previously.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes polarizability for each dipoles using effective dielectric constant \nknorm=2*pi/lambdas[1]\nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    global  alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\nend\n\n#computes input_field, an x-polarized plane-wave propagating along z\ninput_field=InputFields.plane_wave_e(knorm*latt[:,1:3])\n#solves DDA\ne_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")\n#computes cross section\ncs=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Then, we define a array of angle thetas in order to generate a uniform sampling ur of the units vectors in the y-z plane.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#sampling direction an plotting \nthetas=LinRange(0,2*pi,100)\nur=zeros(100,3)\nur[:,3]=cos.(thetas)\nur[:,2]=sin.(thetas)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"using this array of directions, we can compute the differential cross section in all of these directions using PostProcessing.diff_scattering_cross_section_e. This takes the same positional arguments as PostProcessing.compute_cross_sections_e, but just adding the array of directions. It outputs an array containing the differential scattering cross section in all the directions contained in ur.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes differential cross section\nres=PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,ur)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can plot it with a radial projection. This time again, we plot the normalized scattering cross section.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#plotting\nfig2=plt.figure()\nax2 = fig2.add_subplot(projection=\"polar\")\nax2.set_title(L\"log(d Q_{sca}/ d \\Omega)\")\nax2.plot(thetas,log10.(res/pi/(a^2)),label=\"y-z plane\")\nplt.tight_layout()\nfig2.savefig(\"diff_Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/diff_Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"On this plot, the input wave is coming from the left side. We see that most of the light is forward scattered. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"For a sanity check, we can try to integrate the differential scattering cross section on the unit sphere using Lebedev.jl and compare with the total scattering cross section. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#Compare total scattering cross section and integral of the differential one\nx,y,z,w = lebedev_by_order(13)\ncsca_int=4 * pi * dot(w,PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,[x y z]))\nprintln(cs[3],\" : \",csca_int)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It outputs","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"50042.00684959106 : 50042.00684909766\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"showing, that they are the same.","category":"page"},{"location":"example_PS_sphere/#A-Note-on-Convergence","page":"PS Sphere","title":"A Note on Convergence","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"As seen in the previous sections, the scattering cross section obtained with N=720 cubes/dipoles don't match perfectly with the mie solution (a bit more than 1%). But what happens if we change the number of cubes? We repeated the calculations of the total scattering cross section but with several number of dipoles (from 117 to 9549). Here are the results: ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/test_conv.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"What we see is that the error starts to be way smaller for numbers of dipoles bigger than 2295. The example of the PS sphere works quite well, but be careful, this doesn't mean that it will converge like that for every types of spheres. If you want to do that with another sphere made of another material or another object, check the convergence!. Recall also that DDA is not the best method to solve light scattering problems by a sphere. If you don't really need it, prefer to use Mie Theory.","category":"page"},{"location":"example_ldos_silver_np/#Local-density-of-states-for-a-metallic-nanoparticle","page":"LDOS Silver Particle","title":"Local density of states for a metallic nanoparticle","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This example aims to teach the user how to use other advanced utilities such as the local density of states (LDOS) by reproducing the results of R. Carminati et. al., Opt. Comm. 261, 368 (2006). The system under study is a silver particle of radius 5 nm around its plasmon-resonance frequency (lambda = 354 nm) and at out-of-resonance (lambda = 612 nm). The numerical projected LDOS is then compared with the analytical results derived in the manuscript.  ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"If you want to run this example, copy it or download it on the github (example_ldos_silver_np.jl) and run it using ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"julia example_ldos_silver_np.jl\n","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use PyCall, because we will use the python matplotlib library in order to plot the results.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_ldos_silver_np/#Defining-analytical-solutions-from-R.-Carminati-et.-al.,-Opt.-Comm.-261,-368-(2006)","page":"LDOS Silver Particle","title":"Defining analytical solutions from R. Carminati et. al., Opt. Comm. 261, 368 (2006)","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let first define the analytical solution of the LDOS, that it takes as inputs the dimensionless distance kz and polarizability alp_dl, and the outputs are the projected LDOS along the z- and x-axis. By definition, the silver nanoparticle will be placed at the origin of the coordinate system, and the LDOS is measured along the z-axis.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# analytic solution R. Carminati et. al., Opt. Comm. 261, 368 (2006)\nfunction ldos_analytic(kz, alp_dl)\n    ldos_z = 1 + 6*imag(alp_dl*exp(2*im*kz)*(-1/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    ldos_x = 1 + 3/2*imag(alp_dl*exp(2*im*kz)*(1/kz^2 + 2*im/kz^3 - 3/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    return ldos_z, ldos_x\nend\nfunction nonrad_ldos_analytic_shortdistance(kz, alp_dl)\n    ldos_z = 6*(imag(alp_dl) - 2/3*abs2(alp_dl))*(1/kz^4 + 1/kz^6) \n    ldos_x = 3/2*(imag(alp_dl) - 2/3*abs2(alp_dl))*(1/kz^2 - 1/kz^4 + 1/kz^6) \n    return ldos_z, ldos_x\nend\nfunction rad_ldos_analytic_shortdistance(kz, alp_dl)\n    ldos_z = 1 + 4*abs2(alp_dl)*(1/kz^4 + 1/kz^6) + 4*real(alp_dl)/kz^3\n    ldos_x = 1 + abs2(alp_dl)*(-1/kz^4 + 1/kz^6) - 2*real(alp_dl)/kz^3\n    return ldos_z, ldos_x\nend","category":"page"},{"location":"example_ldos_silver_np/#Setting-physical-properties","page":"LDOS Silver Particle","title":"Setting physical properties","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Now let's set the parameters of the system, as well as the variables where the LDOS will be stored.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# physical properties\n# particle radius\na = 5\n# wavelengths\nlamb = [612, 354] \n# dielectric constant of the particle\neps=[-15.04 + im*1.02, -2.03 + im*0.6] \n# distance between particle and dipole \nnz = 91 \nz = LinRange(10,100,nz)\n\n# variables to store the calculations\nldos_z = zeros(nz,2) \nldos_x = zeros(nz,2)\nldos_z_analytic = zeros(nz,2) \nldos_x_analytic = zeros(nz,2)\nrad_ldos_z = zeros(nz,2) \nrad_ldos_x = zeros(nz,2)\nrad_ldos_z_analytic_shortdistance = zeros(nz,2) \nrad_ldos_x_analytic_shortdistance = zeros(nz,2)\nnonrad_ldos_z = zeros(nz,2) \nnonrad_ldos_x = zeros(nz,2)\nnonrad_ldos_z_analytic_shortdistance = zeros(nz,2) \nnonrad_ldos_x_analytic_shortdistance = zeros(nz,2)","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"The values of the permittivity is taken directly from the manuscript, that correspond with the permittivity at the specific wavelengths, as can be checked in E.W. Palik, Handbook of Optical Constants of Solids, Academic Press, San Diego, 1985 for bulk silver. ","category":"page"},{"location":"example_ldos_silver_np/#Computing-the-LDOS","page":"LDOS Silver Particle","title":"Computing the LDOS","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"We can then open a loop and computes the LDOS as follows:","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# ldos calculation at both wavelengths and all distances\nfor i=1:2 # loop in wavelength\n    # wavevector\n    knorm = 2*pi/lamb[i] \n    # permittivity\n    eps_i = eps[i] \n    # calculation of the polarizability\n    alp_0 = Alphas.alpha0_sphere(a,eps_i,1) # static polarizability\n    alp_e_dl = Alphas.alpha_radiative(alp_0,knorm) # dimensionless polarizability with radiative corrections\n    for j=1:nz # loop in distance\n        # distance\n        z_j = z[j] \n        # renormalized distance\n        kz = knorm*z_j\n        # renormalized position of the particle (at the origin of coordinates) \n        kr = zeros(1,3) \n        # renormalized position of the diple (z-component at kz)\n        krd = zeros(1,3) \n        krd[3] = kz\n        # analytic ldos\n        global ldos_z_analytic[j,i], ldos_x_analytic[j,i] =  ldos_analytic(kz, alp_e_dl) \n        # numerical ldos\n        Ainv = DDACore.solve_DDA_e(kr,alp_e_dl) # calculation inverse dda matrix\n        global ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 3) # ldos z-axis\n        global ldos_x[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 1) # ldos x-axis\n\n        # analytic ldos at short distances for radiative and non radiative components\n        global rad_ldos_z_analytic_shortdistance[j,i], rad_ldos_x_analytic_shortdistance[j,i] =  rad_ldos_analytic_shortdistance(kz, alp_e_dl)\n        global nonrad_ldos_z_analytic_shortdistance[j,i], nonrad_ldos_x_analytic_shortdistance[j,i] =  nonrad_ldos_analytic_shortdistance(kz, alp_e_dl)\n\n        # numerical ldos for radiative and non radiative components\n        dip_z = zeros(3)\n        dip_z[3] = 1\n        dipole_field = InputFields.point_dipole_e(kr, krd[:], dip_z) # field of the point dipole with dipole moment \"dip_z\"\n        phi_inc = DDACore.solve_DDA_e(kr,alp_e_dl;input_field=dipole_field)     # incident field at the silver particle \n        dipole_moment = PostProcessing.compute_dipole_moment(alp_e_dl,phi_inc) # dipole moment at the silver particle\n        global rad_ldos_z[j,i] = PostProcessing.rad_ldos_e(kr,krd,dipole_moment,dip_z)          # radiative ldos z-axis\n        global nonrad_ldos_z[j,i] = PostProcessing.nonrad_ldos_e(dipole_moment,phi_inc,dip_z)   # non-radiative ldos z-axis\n\n        dip_x = zeros(3)\n        dip_x[1] = 1\n        dipole_field = InputFields.point_dipole_e(kr, krd[:], dip_x) # field of the point dipole with dipole moment \"dip_x\"\n        phi_inc = DDACore.solve_DDA_e(kr,alp_e_dl;input_field=dipole_field)     # incident field at the silver particle \n        dipole_moment = PostProcessing.compute_dipole_moment(alp_e_dl,phi_inc) # dipole moment at the silver particle\n        global rad_ldos_x[j,i] = PostProcessing.rad_ldos_e(kr,krd,dipole_moment,dip_x)          # radiative ldos x-axis\n        global nonrad_ldos_x[j,i] = PostProcessing.nonrad_ldos_e(dipole_moment,phi_inc,dip_x)   # non-radiative ldos x-axis\n\n    end\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"The selection of the projection of the LDOS is done by the dip argument. It is also possible to pass an array as an argument, defining the dipole moment of the testing dipolar source as","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"dip_vec = zeros(3)\ndip_vec[3] = 1 \nglobal ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = dip_vec) # ldos z-axis","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This way of calculating the projection along the z-axis would lead to the same result. Also, dip could be any three (of six for electric and magnetic dipoles) dimensional vectors.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"It is now possible to plot the LDOS, comparing the numerical and analytical calculations. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# plot ldos\npas = 5 \nfor ind_l = 1:2\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSx lambda = \"*string(Int(lamb[ind_l]))*\" nm\")\n    axs.plot(z,ldos_x_analytic[:,ind_l],\"--b\",label=\"total analytic\")\n    axs.plot(z,rad_ldos_x_analytic_shortdistance[:,ind_l],\"--r\",label=\"radiative analytic\")\n    axs.plot(z,nonrad_ldos_x_analytic_shortdistance[:,ind_l],\"--g\",label=\"non radiative analytic\")\n    axs.plot(z[1:pas:end],ldos_x[1:pas:end,ind_l],\"ob\",label=\"total DDA\")\n    axs.plot(z[1:pas:end],rad_ldos_x[1:pas:end,ind_l],\"or\",label=\"radiative DDA\")\n    axs.plot(z[1:pas:end],nonrad_ldos_x[1:pas:end,ind_l],\"og\",label=\"non radiative DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_x\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSx\"*string(Int(lamb[ind_l]))*\".svg\")\n\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSz lambda = \"*string(Int(lamb[ind_l]))*\" nm\")\n    axs.plot(z,ldos_z_analytic[:,ind_l],\"--b\",label=\"total analytic\")\n    axs.plot(z,rad_ldos_z_analytic_shortdistance[:,ind_l],\"--r\",label=\"radiative analytic\")\n    axs.plot(z,nonrad_ldos_z_analytic_shortdistance[:,ind_l],\"--g\",label=\"non radiative analytic\")\n    axs.plot(z[1:pas:end],ldos_z[1:pas:end,ind_l],\"ob\",label=\"total DDA\")\n    axs.plot(z[1:pas:end],rad_ldos_z[1:pas:end,ind_l],\"or\",label=\"radiative DDA\")\n    axs.plot(z[1:pas:end],nonrad_ldos_z[1:pas:end,ind_l],\"og\",label=\"non radiative DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_z\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSz\"*string(Int(lamb[ind_l]))*\".svg\")\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This is what we get:","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx612.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz612.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Electromagentic-forces-of-a-Gaussian-Beam-on-a-Polystyrene-Sphere","page":"Optical Trap","title":"Electromagentic forces of a Gaussian Beam on a Polystyrene Sphere","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"This example aims to teach the user how to calculate optical forces, as well as to calculate the field and its derivatives of a tight-focused Gaussian beam. Note that the derivatives are implemented as adimensional. Thus, both the field and the derivatives would have the same units.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"The forces will be calculated along the three axes, x-, y- and z-axis. For example, for the forces along the x-axis, we will take y = z = 0 (and the same for the other axis). Also, with the forces along a given axis, we mean that the input field is a Gaussian beam focus at the origin of coordinates, while the force is calculated as a function of the position of the center of the Polystyrene Sphere. Nonetheless, in order to avoid the recalculation of the DDA matrix, in the calculation the particle is fixed at the center of coordinates, while the focus of the Gaussian Beam is moving.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"If you want to run this example, copy it or download it on the github (example_force_gaussbeam_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"julia example_force_gaussbeam_PS_spher.jl\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"If you can, it is recommended to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra is used for....","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Discretizing-the-Sphere-and-polarizability","page":"Optical Trap","title":"Discretizing the Sphere and polarizability","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"We then need to start modeling our particle in water. The parameters are the same used for example_PS_sphere.jl. Thus, please visit this example for more details.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"##################### Parameters ########################################\n#radius of the sphere\na=0.25\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute\nN_lambda=10\nlambda_min=1\nlambda_max=1.1\n#wavelengths to compute\nlambdas0=LinRange(lambda_min,lambda_max,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################\n\n#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)\nn=length(latt[:,1])\n\n# Parameters for the forces at lambda_0 = 1000 nm\n# wavelength\nlamb = lambdas[1]\n# wavevector\nknorm=2*pi/lamb\n# renormalized distance of the dipoles\nkr = knorm*latt[:,1:3]\n\n#computes polarizability for each dipoles using effective dielectric constant \nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\nend\n# calculation of the inverse DDA matrix\nAinv = DDACore.solve_DDA_e(kr,alpha)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Note that in this example DDACore.solve_DDA_e has no input_field argument. Then, the output is the inverse DDA matrix. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Setting-incoming-field-and-particle-position","page":"Optical Trap","title":"Setting incoming field and particle position","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"As an incoming field, we will use a Gaussian Beam with beam waist radius bw_0 = lambda2, that in adimensional units is knorm*bw_0 = pi. Also, the forces will be calculated along the three axes, between [-2\\lambda, 2\\lambda], discretizing the space in 51 points. For convenience, it is better to use an odd number of points in order to take the 0.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# parameters of the Gaussian Beam\n# beam waist radius is set to lamb/2\nkbw0 = pi # (2*pi/lambda)*(lamb/2)\n\n# discretization of the position of the particle\nndis = 51 # odd number in order to mesh the \"0\" position\ndis = LinRange(-2*lamb,2*lamb,ndis)\n# variable where the force will be stored\nforce = zeros(ndis,3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"For knowing what is the field distribution of this field, the file example_plot_gauss_beam.jl can be runned.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-the-forces","page":"Optical Trap","title":"Calculating the forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Finally, we can then open a loop and computes the forces as follow:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# loop on distances \n# note that, instead of moving the particle (and avoiding to recalculate the inverse DDA matrix), the position of the focus \n# of the Gaussian beam is changed.\nfor i=1:ndis \n    # forces along the x-axis when the particle is moving along the same axis (with y = z = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [dis[i] 0 0])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,1] = sum(fx)\n\n    # forces along the y-axis when the particle is moving along the same axis (with z = x = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [0 dis[i] 0])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,2] = sum(fy)\n\n    # forces along the z-axis when the particle is moving along the same axis (with x = y = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    krf = (latt[:,1:3] .+ [0 0 dis[i]])*knorm\n    e_0inc = InputFields.gaussian_beam_e(krf,kbw0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gaussian_beam_e(krf,kbw0)\n    # calculation of forces\n    fx, fy, fz = Forces.force_e(kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,3] = sum(fz)\nend","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"As it is explained above, for the calculation the Polystyrene Sphere is keeped at the origin of coordinates, while the focus of the derivatives beam is changed. However, (for reciprocity) we interpret the results as the forces on the Polystyrene Sphere as it is moving out the focus. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"To save the data, uncomment the last lines and include \"using DelimitedFiles\".","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Expressing-forces-in-Newtons","page":"Optical Trap","title":"Expressing forces in Newtons","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"The output of the function for the forces is adimensional (or more explicitly, the same unit that the square of the external field). In order to express the forces in Newtons it is necessary to multiply by a factor epsilon_0epsilon_h 4 pi k^2 (a factor 4 pi k^3 that accounts for the adimensionality of the polarizability and a factor k since the spatial derivatives of the Green function and of the external field are adimensional), where the field, epsilon_0 and k must be in SI units. Also, in the calculation of the Gaussian beam field we have set E_0 = 1 (value by default), and the force must be scaled according to the intensity of the beam. Thus, assuming that our laser source has a power of P = 10 mW, we can proceed as follows.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"First, for simplicity let's consider that the intensity distribution at the focus also follows a Gaussian distribution,  I(xyz=0) = I_0 e^2fracx^2 + y^2bw_0^2,  with  I_0 = dfrac12c epsilon_0epsilon_h E_0^2, being c the speed of light in the medium. Under this approximation (not totally accurate since the beam is tight focused), the power of the beam can be calculated as the surface integral of the intensity at the focus plane P = I_0 int_z=0 e^2fracx^2 + y^2bw^2 = I_0 pi dfracbw_0^22. Thus, to convert the forces in unit of Newton, the calculated forces must be multiplied by  epsilon_0epsilon_h 4 pi k^2 E_0^2 = dfrac16 Pc (kwb_0)^2.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"For the gaussian beams implemented in the library (gaussian, hermite and legendre beams), there is a function in the Force module called Forces.force_factor_gaussianbeams that calculates this proportionality factor. Thus, just write:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# converse forces in Newtons\n# laser intensity (10 mW)\npower = 10e-3\nfactor = Forces.force_factor_gaussianbeams(kbw0,power,eps_h)\n# force in Newtons\nforce = force*factor","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-stiffnesses","page":"Optical Trap","title":"Calculating stiffnesses","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Since the tight-focused Gaussian beam is going to trap the particle, the forces around the equilibrium position can be approximated by a linear model. The depth of the trap can be characterized by the stiffnesses along the different axis, a simple spring model. To estimate the stiffnesses, a linear fit can be done.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# calculation of the stiffnesses of the trap by a linear fit around the zero force position\n# for kx and ky, we directly assume that the zero force position is at the minimum of the \"dis\" array (at dis = 0)\n# find the position of the minimum\nval, ind_min_xy = findmin(abs.(dis))\n# calculation of the stiffnesses along the x- and y-axis\nkx = -(force[ind_min_xy+1,1]-force[ind_min_xy-1,1])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\nky = -(force[ind_min_xy+1,2]-force[ind_min_xy-1,2])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\n# for kz the minimum is found as the first minimum along the z-axis (the minimum is not at \"z=0\")\nind_min_z = ind_min_xy\nwhile abs(force[ind_min_z,3]) > abs(force[ind_min_z+1,3])\n    min_z = ind_min_z + 1\n    global ind_min_z = min_z\nend\n# calculation of the stiffnesses along the z-axis\nkz = -(force[ind_min_z+1,3]-force[ind_min_z-1,3])/(dis[ind_min_z+1] - dis[ind_min_z-1])\n# linear calculation of for the position of the minimum\nzmin = dis[ind_min_z] + force[ind_min_z,3]/kz\n# shorter array for plotting the linear approximation of the forces\ndis_short = LinRange(-lamb/4,lamb/4,ndis)\n# linear approximation of the force around the zero\nfx_lin = -kx*dis_short\nfy_lin = -ky*dis_short\nfz_lin = -kz*(dis_short)\n# rounding the value of the stiffnesses for the legend\nkx = round(kx*1e6,sigdigits=3)\nky = round(ky*1e6,sigdigits=3)\nkz = round(kz*1e6,sigdigits=3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Plotting-forces","page":"Optical Trap","title":"Plotting forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Once the forces and the stiffnesses are calculated, they can be plotted using the next lines:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# plotting results\nfig, axs = plt.subplots()\naxs.set_title(L\"x-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,1]*1e15,label=\"\")\naxs.plot(dis_short*1e9,fx_lin*1e15,\"--\",label=\"kx = \"*string(kx)*\" fN/nm\")\naxs.set_xlabel(\"x (nm)\")\naxs.set_ylabel(\"Fx (fN)\")\naxs.legend()\nfig.savefig(\"fx.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"y-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,2]*1e15)\naxs.plot(dis_short*1e9,fy_lin*1e15,\"--\",label=\"ky = \"*string(ky)*\" fN/nm\")\naxs.set_xlabel(\"y (nm)\")\naxs.set_ylabel(\"Fy (fN)\")\naxs.legend()\nfig.savefig(\"fy.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"z-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,3]*1e15)\naxs.plot((dis_short .+ zmin)*1e9,fz_lin*1e15,\"--\",label=\"kz = \"*string(kz)*\" fN/nm\")\naxs.plot(dis*1e9,force[:,3]*0,\"k--\")\naxs.set_xlabel(\"z (nm)\")\naxs.set_ylabel(\"Fz (fN)\")\naxs.legend()\nfig.savefig(\"fz.svg\")","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fx.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fy.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fz.svg\">","category":"page"},{"location":"miecoeff/#Mie-Coefficients","page":"MieCoeff","title":"Mie Coefficients","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"MieCoeff is a small module for computing Mie Coefficients. It also contains some useful function to compute cross sections from the Mie theory. ","category":"page"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"Expressions are taken in Craig F. Bohren, Donald R. Huffman, Absorption and Scattering of Light by Small Particles (1998).","category":"page"},{"location":"miecoeff/#Functions-Documentation","page":"MieCoeff","title":"Functions Documentation","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_an(ka, eps, eps_h; mu=1, mu_h=1, n=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an","text":"mie_an(ka, eps, eps_h; mu=1, mu_h=1, n=1)\n\nComputes the n-th mie coefficient a_n of a sphere with dimensionless radius ka, and of dielectric permittivity and magnetic permeability eps and mu, in a host medium with dielectric permittivity and magnetic permeability eps_h and mu_h. Returns a complex scalar.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_bn(ka, eps, eps_h; mu=1, mu_h=1, n=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn","text":"mie_bn(ka, eps, eps_h; mu=1, mu_h=1, n=1)\n\nComputes the n-th mie coefficient b_n of a sphere with dimensionless radius ka, and of dielectric permittivity and magnetic permeability eps and mu, in a host medium with dielectric permittivity and magnetic permeability eps_h and mu_h. Returns a complex scalar. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_ab1(ka, eps, eps_h; mu=1, mu_h=1)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_ab1-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_ab1","text":"mie_ab1(ka, eps, eps_h; mu=1, mu_h=1)\n\nComputes the first mie coefficient a_1 and b_1 of a sphere with dimensionless radius ka, and of dielectric permittivity and magnetic permeability eps and mu, in a host medium with dielectric permittivity and magnetic permeability eps_h and mu_h. Returns a tuple with two complex scalar, a_1 and b_1, respectively. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_extinction(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction-Tuple{Any, Any, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction","text":"mie_extinction(ka,eps,eps_h;cutoff=20)\n\nComputes the extinction efficiency Q_ext of a sphere with dimensionless radius ka, and of dielectric permittivity and magnetic permeability eps and mu, in a host medium with dielectric permittivity and magnetic permeability eps_h and mu_h. For this, we use:\n\nQ_ext =frac2(ka)^2sum^infty_n=1left(2n+1right)Releft(a_n+b_nright)\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 20).\n\nReturns a float.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_absorption(ka,eps,eps_h;mu=1,mu_h=1,cutoff=20)cutoff=20)","category":"page"},{"location":"forces/#Optical-Forces","page":"Forces","title":"Optical Forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"The Forces module allows to computes optical forces on electric and magnetic dipoles with deterministic input fields. The list of functions is below. Note that N is the number of dipoles in the system. ","category":"page"},{"location":"forces/#Functions-Documentation","page":"Forces","title":"Functions Documentation","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e","text":"force_e(kr,alpha_e_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric dipoles for deterministic input fields. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_r 4pik^2, taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 3 containing the external input field.\ndxe_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*x argument of the external input field.\ndye_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*y argument of the external input field.\ndze_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*z argument of the external input field.\n\nOutputs\n\nreal(fx): float array of Size N with the value of the force along the x-axis at each dipole.\nreal(fy): float array of Size N with the value of the force along the y-axis at each dipole.\nreal(fz): float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\n","category":"function"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e_m","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e_m","text":"force_e_m(kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric and magnetic dipoles for deterministic input fields. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_r 4pik^2, taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 6 containing the external input field.\ndxe_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*x argument of the external input field.\ndye_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*y argument of the external input field.\ndze_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*z argument of the external input field.\n\nOutputs\n\nreal(fx): float array of Size N with the value of the force along the x-axis at each dipole.\nreal(fy): float array of Size N with the value of the force along the y-axis at each dipole.\nreal(fz): float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\nforce_e_m(kr,alpha_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nSame as force_e_m(knorm,kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats. The output force has units of the input electric field squared. To get unit of forces, it is necessary to multiply by a factor epsilon_0epsilon_r 4pik^2,  taking care that the units of the field, the vacuum permittivity and the wavevector are in accordance.\n\n\n\n\n\n","category":"function"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_factor_gaussianbeams","text":"force_factor_gaussianbeams(kbw0,power,eps_h;n=0,m=0,,kind=\"hermite\", e0 = 1, paraxial=true, kmax = nothing, maxe=Int(1e4), int_size = 5)\n\nComputes the proportionality factor to get the forces in units of Newtons when the forces are calculated using the Gaussian beams (Hermite and Laguerre) implemented in the library.  By default, the factor is calculated for a Gaussian Beam in the paraxial approximation.\n\nArguments\n\nkbw0: float with the dimensionless beam waist radius (komega_0, where omega_0 is the beam waist radius).\npower: float with the power of the beam.\neps_h: float with the relative permittivity of the host medium.\nn: non-negative int with the radial order of the beam.\nm: int with the azimuthal order of the beam.\ne0: float with the modulus of the electric field used in the calculation of the beam profile. \nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). \nparaxial: boolean setting if the calculation is done in the paraxial approximation.\nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptive integral (see Cubature.jl for more details).\nint_size: size of the integration area in units of kbw0. For high-order beams this parameter should be adjusted.\n\nOutputs\n\nint_amplitude: integral of the field amplitude (|E|^2) in the area defined by intsize (x = [-kbw0*intsize, kbw0int_size], y = [-kbw0intsize, kbw0*intsize]).\n\n\n\n\n\n","category":"function"},{"location":"geometries/#Geometries-library","page":"Geometries","title":"Geometries library","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"Geometries is a small modules allowing to discretize primitives in small cubes that can be later used in the DDA. The two primitives that are proposed are a sphere and a cube. The description of the two functions are given in the next section. Note that the discretization of the sphere implements anti-aliasing (see Wikipedia page for anti-aliasing or the PS sphere example).","category":"page"},{"location":"geometries/#Functions-Documentation","page":"Geometries","title":"Functions Documentation","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_sphere","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","text":"discretize_sphere(a,N;N_sub=10)\n\nDiscretizes the volume of a sphere of radius a in small cubes of edge dx=2*a/N. N_sub is a parameter to set the anti-aliasing accuracy of the discretisation. It is by default set to 10. If N_d is the obtained number of cubes, the output is an N_d times 4 array containing the 3D position of the centers of the cubes and their filling fraction. Returns as well the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"function"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_cube(L,N)","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube-Tuple{Any, Any}","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube","text":"discretize_cube(L,N)\n\nDiscretizes the volume of a cube of edge L in small cubes of edge dx=L/N. If N_d is the obtained number of cubes, the output is an N_d times 4 array containing the 3D position of the centers of the cubes and their filling fraction (i.e. 1). Returns as well the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Post-Processing","page":"PostProcessing","title":"Post Processing","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The PostProcessing module allows you to process the results of a CEMD calculation. Mostly for:","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"Computing cross sections and differential emitted power. \nComputing scattered fields.\nComputing local density of states (LDOS).","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The list of functions and a description of how to use them is given in the following section. In general N represents the number of dipoles.","category":"page"},{"location":"postprocessing/#Functions-List-and-Documentation","page":"PostProcessing","title":"Functions List and Documentation","text":"","category":"section"},{"location":"postprocessing/#Functions-for-Cross-Sections-and-Differential-Emitted-Power","page":"PostProcessing","title":"Functions for Cross Sections and Differential Emitted Power","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e(knorm,kr,e_inc,alpha,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e","text":"compute_cross_sections_e(knorm,kr,e_inc,alpha_e_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric dipoles, in a plane wave input field. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it must be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric and magnetic dipoles, in a plane wave input field. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)\n\nSame as compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e","text":"diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric dipoles in direction(s) ur.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it should be a plane wave\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r where the diffrential scattering cross section is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric and magnetic dipoles in direction(s) ur.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r where the diffrential scattering cross section is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)\n\nSame as compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e(knorm,kr,e_inc,alpha_e_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e","text":"diff_emitted_power_e(knorm,kr,e_inc,alpha_e_dl,krf,phi_inp_krf;verbose=true)\n\nComputes the differential emitted power d P dOmega of a system made out of electric dipoles in direction(s) of position(s) krf.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole.\nkrf: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r in which direction the diffrential emitted power is computed. Note that the magnitude of these position must be way bigger than the dipoles positions.\nphi_inp_krf: like input_field, but evaluated at the krf positions.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in direction directions.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m","text":"diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)\n\nComputes the differential emitted power d P dOmega of a system made out of electric and magnetic dipoles in direction(s) of position(s) krf.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole.\nkrf: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r in which direction the diffrential emitted power is computed. Note that the magnitude of these position must be way bigger than the dipoles positions.\nphi_inp_krf: like input_field, but evaluated at the krf positions.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in direction directions.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m","text":"diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)\n\nSame as diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-Scattered-Fields","page":"PostProcessing","title":"Functions for Scattered Fields","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e(kr, alpha_e_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e","text":"function field_sca_e(kr, alpha_e_dl, e_inc, krf)\n\nComputes the scattered field from a system made out of electric dipoles.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf; verbose=true)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_dl, phi_inc, krf)\n\nSame as field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e(kr, alpha_e_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e","text":"function far_field_sca_e(kr,e_inc,alpha_e_dl,krf)\n\nComputes the scattered field from a system made out of electric dipoles in the far field approximation.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_e_dl,alpha_m_dl,krf)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles in the far field approximation.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_dl,krf)\n\nSame as far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-LDOS","page":"PostProcessing","title":"Functions for LDOS","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e","text":"ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing, verbose=true)\n\nIt Computes local density of states (LDOS) of a system made out of electric dipoles by the imaginary part of the returning field.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 3 with the desired dipole moment of the dipole.  \nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true)\n\nComputes local density of states (LDOS) of a system made out of electric and magnetic dipoles by taking the imaginary part of the returning field.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 6 with the desired dipole moment of the dipole.  \nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing, verbose=true)\n\nSame as ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e(kr,krd,p,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e","text":"rad_ldos_e(kr,krd,p,dip;verbose=true)\n\nComputes the radiative part of the LDOS of a system of electric dipoles with a point dipole source.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\ndip: 1D complex vector of size 3 containing the dipole moment of the source dipole.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\n1D float array containing the normalized radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m(kr,krd,p,m,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.rad_ldos_e_m","text":"rad_ldos_e_m(kr,krd,p,m,dip;verbose=true)\n\nComputes the radiative part of the LDOS of a system of electric and magnetic dipoles with a point dipole source.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\nm: 2D complex array of sizeNdtimes 3 containing the magnetic dipole moments of the dipoles.\ndip: 1D complex vector of size 3 containing the dipole moment of the source dipole.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\n1D float array containing the normalized radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e(p,e_inc,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e-Tuple{Any, Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e","text":"nonrad_ldos_e(p,e_inc,dip;verbose=true)\n\nComputes the non-radiative part of the LDOS of a system of electric dipoles with a point dipole source.\n\nArguments\n\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\ndip: 1D complex vector of size 3 containing the dipole moment of the source dipole.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\n1D float array containing the normalized non-radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m(p,m,phi_inc,dip;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.nonrad_ldos_e_m","text":"nonrad_ldos_e_m(p,m,phi_inc,dip;verbose=true)\n\nComputes the non-radiative part of the LDOS of a system of electric dipoles with a point dipole source.\n\nArguments\n\np: 2D complex array of sizeNdtimes 3 containing the electric dipole moments of the dipoles.\nm: 2D complex array of sizeNdtimes 3 containing the magnetic dipole moments of the dipoles.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\ndip: 1D complex vector of size 3 containing the dipole moment of the source dipole.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\n1D float array containing the normalized non-radiative LDOS at everey position of krd.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Utilities-Functions","page":"PostProcessing","title":"Utilities Functions","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment(alpha,phi_inc)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment-Tuple{Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment","text":"compute_dipole_moment(alpha,phi_inc)\n\nComputes the dipole moment (magnetic or electric) of a dipole with polarizability alpha under an incident field phi_inc. alpha can be:\n\na complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.poynting_vector(phi)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector-Tuple{Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector","text":"poynting_vector(phi)\n\nComputes the poynting vector of an electromagnetic field. Input is an electric and magnetic field phi(1D complex Array of length 6). Outputs a 1D float array of length 3.\n\n\n\n\n\n","category":"method"},{"location":"green/#Green-Tensors","page":"GreenTensors","title":"Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"GreenTensors is a module aimed to compute the renormalized electric and magnetic Green's tensors. To learn more about the renormalization and the expressions that are used, please see the theory part.","category":"page"},{"location":"green/#Functions-Documentation","page":"GreenTensors","title":"Functions Documentation","text":"","category":"section"},{"location":"green/#Renormalized-Green-Tensors","page":"GreenTensors","title":"Renormalized Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","text":"G_e_renorm(kr1,kr2)\n\nComputes the renormalized electric Green's tensor between two position r1 and r2, where the inputs are the positions multiplied by the wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","text":"G_m_renorm(kr1,kr2)\n\nComputes the renormalized magnetic Green's tensor between two position r1 and r2, where the inputs are the positions multiplied by the wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","text":"G_em_renorm(kr1,kr2)\n\nComputes the renormalized electric and magnetic Green's tensors between two position r1 and r2, where the inputs are the positions multiplied by the wave number kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","text":"G_em_far_field_renorm(kr1,kr2)\n\nComputes the renormalized electric and magnetic Green's tensors in the far field approximation between two dimensionless position kr1 and kr2. Note that is is only valid for kr_1kr_2 and kr_11 The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/#Derivatives-of-the-Renormalized-Green-Tensors","page":"GreenTensors","title":"Derivatives of the Renormalized Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","text":"dxG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric Green's tensor (defined in G_e_renorm(kr1,kr2)) regarding the kx component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","text":"dyG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric Green's tensor (defined in G_e_renorm(kr1,kr2)) regarding the ky component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","text":"dzG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric Green's tensor (defined in G_e_renorm(kr1,kr2)) regarding the kz component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","text":"dxG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic Green's tensor (defined in G_m_renorm(kr1,kr2)) regarding the kx component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","text":"dyG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic Green's tensor (defined in G_m_renorm(kr1,kr2)) regarding the ky component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","text":"dzG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic Green's tensor (defined in G_m_renorm(kr1,kr2)) regarding the kz component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","text":"dxG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic Green's tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the kx component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","text":"dyG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic Green's tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the ky component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","text":"dzG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic Green's tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the kz component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/#Utilities-Functions","page":"GreenTensors","title":"Utilities Functions","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","text":"denormalize_G_e(Ge,knorm)\n\nPasses from a dimensionless electric Green's tensor Ge to a Green's tensor with units of length⁻¹. knorm is the wavenumber into the medium.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","text":"denormalize_G_m(Gm,knorm)\n\nPasses from a dimensionless magnetic Green's tensor Gm to a Green's tensor with units of length⁻². knorm is the wavenumber into the medium.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Input-Fields","page":"InputFields","title":"Input Fields","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"This module allows to compute input fields. It also implements derivatives of some of the beams.","category":"page"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"See the theory part to know more about the expression used to compute the input fields. In general N represents the number of input positions. ","category":"page"},{"location":"input_fields/#Functions-Documentation","page":"InputFields","title":"Functions Documentation","text":"","category":"section"},{"location":"input_fields/#Plane-Waves","page":"InputFields","title":"Plane Waves","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","text":"plane_wave_e(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at krf. khat is the direction of propagation and e0 is the polarization. The user is responsible for using physical inputs. krf is a Ntimes 3 float array.  The output is a Ntimes 3 complex array representing the electric field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","text":"plane_wave_e_m(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at krf. khat is the direction of propagation and e0 is the polarization.The user is responsible for using physical inputs. krf is a Ntimes 3 float array.  The output is a Ntimes 6 complex array representing the electric and magnetic fields.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Point-Dipoles-Sources","page":"InputFields","title":"Point Dipoles Sources","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","text":"point_dipole_e(krf, krd, dip, e0_const=1)\n\nComputes the electric field emitted by a point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where the source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an electric y-dipole...) or complex array of size 6 with the desired dipole moment of the dipole.  \ne0: scalar with the modulus of the dipole moment. \n\nOutputs\n\ne_dipole:2D Ntimes 3 complex array with the electromagnetic field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","text":"point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the electric and magnetic fields emitted by a point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where the source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an electric y-dipole...) or complex array of size 6 with the desired dipole moment of the dipole.  \ne0: float with the modulus of the dipole moment. \n\nOutputs\n\nphi_dipole: 2D Ntimes 6complex array with the electromagnetic fields at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Gaussian,-Hermite-Gaussian-and-Laguerre-Gaussian-Beams","page":"InputFields","title":"Gaussian, Hermite-Gaussian and Laguerre-Gaussian Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e","text":"gaussian_beam_e(krf, kbw0,n,m; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electric field distribution of a Gaussian, Hermite-Gaussian and Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). By default, the Gaussian beam profile is calculated. For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkbw0: float with the dimensionless beam waist radius (komega_0, where omega_0 is the beam waist radius).\nn: int with the order of the beam.\nm: int with the degree of the beam.\nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). \ne0: float with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptive integral (see Cubature.jl for more details).\n\nOutputs\n\ne_gauss: 2D complex array of size Ntimes 3 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gaussian_beam_e_m","text":"gaussian_beam_e_m(krf, kbw0,n,m; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electromagnetic field distribution of a Gaussian, Hermite-Gaussian and Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). By default, the Gaussian beam profile is calculated. For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkbw0: float with the dimensionless beam waist radius (komega_0, where omega_0 is the beam waist radius).\nn: int with the order of the beam.\nm: int with the degree of the beam.\nkind: string with the kind of beam (\"hermite\" or \"laguerre\"). \ne0: float with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it should be kmax < 1).\nmaxe: maximum number of evaluations in the adaptive integral (see Cubature.jl for more details).\n\nOutputs\n\nphi_gauss: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Derivatives-of-the-Beams","page":"InputFields","title":"Derivatives of the Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","text":"d_plane_wave_e(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the derivatives of an electric field generated with plane_wave_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","text":"d_plane_wave_e_m(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the derivatives of an electromagnetic field generated with plane_wave_e_m (the arguments are the same). Outputs three 2D arrays of size Ntimes 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","text":"d_point_dipole_e(krf, krd, dip, e0=1)\n\nComputes the derivatives of an electric field generated with point_dipole_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","text":"d_point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the derivatives of an electromagnetic field generated with point_dipole_e_m (the arguments are the same). Outputs three 2D arrays of size Ntimes 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e","text":"d_gaussian_beam_e(krf, kbw0; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the derivatives of an electric field generated with gaussian_beam_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gaussian_beam_e_m","text":"d_gaussian_beam_e_m(krf, kbw0; n = 0, m = 0, kind = \"hermite\", e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the derivatives of an electromagnetic field generated with gaussian_beam_e_m (the arguments are the same). Outputs three 2D arrays of size Ntimes 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledElectricMagneticDipoles.jl","page":"Home","title":"CoupledElectricMagneticDipoles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation website for the coupled electric and magnetic dipoles (CEMD), or discrete dipoles approximation (DDA) method implementation in Julia! On this website, you will find all the descriptions of the functions implemented in this library. Please, read carefully the next sections to be ready to code with CoupledElectricMagneticDipoles.jl!","category":"page"},{"location":"#How-to-Use-this-Website-and-Learn-the-Library?","page":"Home","title":"How to Use this Website and Learn the Library?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website is divided into three parts. The first one is the home page, in which you will find all the information to install, run, and begin to use the package. You will find a theory section containing the definitions of the CEMD (DDA) problems and all the mathematical expressions that are used to implement the functions. The second part is dedicated to the 7 submodules of the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DDACore: Contains the functions to solve the coupled dipoles system of equations.\nAlphas: Small module to compute the polarizabilities.\nInputFields: Module with functions for input fields.\nPostProcessing: Module used to compute the scattering, absorption, and extinction cross sections, as well as the scattered field and local density of states (LDOS).\nForces: Module to compute optical forces between dipoles.\nGreenTensors: Contains functions to compute the electric and magnetic or both green tensors.\nGeometries: Small library to discretize some 3D primitives.\nMieCoeff: Contains functions to compute the Mie coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the example tab gives four examples of the use of this library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please have a look at the theory (next section) and the remaining of this page before starting. When ready, have a look at the examples. Note that functions that end in -_e are for systems made out of electric dipoles only and functions ending in -_e_m are for systems with both electric and magnetic dipoles.","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please read carefully the theory if you don't know about the CEMD (DDA) method. This pdf also provides you all the detailed expressions that are use to implement the library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p>You can download the theory document here: <a href=\"assets/CoupledElectricMagneticDipoles.pdf\">Download PDF</a>.</p>","category":"page"},{"location":"#Installing-the-Library","page":"Home","title":"Installing the Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the library is not yet in the big registry of the Julia package manager, you have to download CoupledElectricMagneticDipoles locally to use it. To be able to run it, please run it in your julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add \"path to the library\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this, the package will be precompiled and the dependencies are going to be installed. Then, you will be able to import the library, by using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the library is installed and activated, we strongly recommend you try to run one example to see if everything works well. You can as well run unit tests (located in CoupledElectricMagneticDipoles/test/unit_tests.jl) to test if everything is well installed. ","category":"page"},{"location":"#Physical-Units","page":"Home","title":"Physical Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computers deal with numbers without units. Therefore, most of the inputs in the functions are dimensionless. For this, some renormalization may be needed. The most used are for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Positions mathbfr (units of L) are multiplied by the wavenumber k (units of L⁻¹), to get dimensionless positions kr.\nPolarizabilities have units of volume (L³). We renormalize it by a factor k^34pi (units of L⁻³) to get dimensionless polarizabilities.\nMagnetic field is multiplied by the impedance Z in the medium. For this, we get a magnetic field that has the same units as the electric field (E, H) becomes (E, ZH). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some functions do not use only dimensionless inputs. In all cases, this is the user's responsibility to send inputs that are coherent in terms of units. For example, it is important to input physical magnitudes with units of length all in the same units (don't put meter and micrometers together). It is recommended to look at the examples where the good practices are used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, ouput ","category":"page"},{"location":"#Running-the-Package-in-Parallel","page":"Home","title":"Running the Package in Parallel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solving the DDA system of equations can be done with two different methods that are parallel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"With LAPACK LU decomposition on multiple CPUs (the number of BLAS threads is set to be equal to the number of Julia threads).\nWith LU decomposition on the GPU (CUDA), by offloading the system on equations in the GPU memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To choose how to set the solver, see the DDACore module library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use it, just set the number of julia threads to use when you run a julia script:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --threads=8 foo.jl","category":"page"},{"location":"#Importing-the-Package-in-Python","page":"Home","title":"Importing the Package in Python","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is possible to run the package from python. See the PyJulia package.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite this software, please use: ...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authors: Augustin Muster, Diego Romero Abujetas, Luis S. Froufe-Pérez.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contact email: augustin@must-r.com","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are open to any comments, ideas, or questions about this software. Don't hesitate to write us, but please be aware that we are not guaranteeing support.","category":"page"}]
}
