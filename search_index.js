var documenterSearchIndex = {"docs":
[{"location":"example_yagi_uda/#Example:-Yagi-Uda-Antenna-Made-Out-of-Silicon-particles.","page":"Yagi-Uda Antenna","title":"Example: Yagi-Uda Antenna Made Out of Silicon particles.","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"In this example, we will simulate an Yagi-Uda antenna made out of small silicon spheres (like in Krasnok et al., Opt. Express 20, 20599-20604 (2012), click here for more information). For this, we will create a linear structure of small as follow: ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/YU_design.png\">","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"At the origin, we place a silicon sphere of 230nm called the reflector. After a bigger spacing of 355nm + 1800nm in which we will place the emitter (an oscillating dipole source aligned along the y-axis), we align on the z axis 10 silicon spheres with radius of 200nm, (center to center spacing: 400nm). We will then compute the total scattering cross section of this structure, as well as the differential cross section, in order to investigate the directionality of this antenna.  ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"We suppose that you already know the example of the PS sphere. So if you don't have a look to it before. If you want to now about the electric and magnetic DDA problem, have a look to the theory as well.","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If you want to run this example, copy it or download it on the github (example_yagi_uda.jl) and run it using ","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"julia example_yagi_uda.jl\n","category":"page"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"If you can, it is recommanded to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_yagi_uda/#Setting-the-Structure","page":"Yagi-Uda Antenna","title":"Setting the Structure","text":"","category":"section"},{"location":"example_yagi_uda/#Modelling-silicon-particles","page":"Yagi-Uda Antenna","title":"Modelling silicon particles","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/mie_dipole_qsca.svg\">","category":"page"},{"location":"example_yagi_uda/#Computing-Emitted-Power","page":"Yagi-Uda Antenna","title":"Computing Emitted Power","text":"","category":"section"},{"location":"example_yagi_uda/","page":"Yagi-Uda Antenna","title":"Yagi-Uda Antenna","text":"<img src=\"../assets/diff_P.svg\">","category":"page"},{"location":"alphas/#Polarizabilities","page":"Alphas","title":"Polarizabilities","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"Alphas is a module to load polarizabilities. In this module, you will find functions to compute electric and magnetic polarizabilities of several objects. The modules also contains some functions to renormalize polarizabilities and to manage  the multiple formats of the polarizabilities (dispatch). The list of functions as well as how to use them is given below. ","category":"page"},{"location":"alphas/#Format-of-the-polarizabilities-in-the-DDACore-and-PostProcessing-functions","page":"Alphas","title":"Format of the polarizabilities in the DDACore and PostProcessing functions","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"The functions of the DDACore and PostProcessing modules come with an automatic dispatch of the format of the polarizability. If we have N dipoles, it can be:","category":"page"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"a complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6","category":"page"},{"location":"alphas/#Functions-Documentation","page":"Alphas","title":"Functions Documentation","text":"","category":"section"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped(lx,ly,lz,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped-NTuple{5, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_parallelepiped","text":"alpha0_parallelepiped(lx,ly,lz,eps,eps_h)\n\nComputes the quasistatic polarizability tensor of a parallelepiped of dimensions lx,ly,lz and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a 3times 3 float matrix with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_sphere(a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_sphere","text":"alpha0_sphere(a,eps,eps_h)\n\nComputes the quasistatic polarizability of a sphere of radiusa and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha0_volume(V,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha0_volume","text":"alpha0_volume(a,eps,eps_h)\n\nComputes the quasistatic polarizability of any object with volume V and dielectric constant eps in a medium with dielectric constant eps_h.  Outputs a float with units of volume.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_radiative(alpha0,knorm)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_radiative","text":"alpha_radiative(alpha0,knorm)\n\nApplies the radiative correction to the polarizability tensor or scalar alpha0(with units of volume). Outputs a (3x3) complex dimensionless scalar or tensor computed as follow:\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie(knorm,a,eps,eps_h)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie-NTuple{4, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.alpha_e_m_mie","text":"alpha_e_m_mie(vac_knorm,a,eps,eps_h)\n\nComputes the electric and magnetic polarizabilities from the mie coefficients a_1 and  b_1 of a particle with radius a and of dielectric constant eps, in a medium with dielectric constant eps_h. knorm` is the wavenumber in the medium. Outputs two dimensionless scalars that are respectively the electric and the magnetic polarizability.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e(alpha_e_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e","text":"dispatch_e(alpha_e_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_e_dl,alpha_m_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i.\n\nArguments\n\nalpha_e_dl: electric polarizability, see the Alphas module's documentation for the accepted formats.\nalpha_m_dl: magnetic polarizability, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp_e: iterable electric polarizability\nalp_m: iterable magnetic polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.dispatch_e_m(alpha_dl,n_particles)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.dispatch_e_m","text":"dispatch_e_m(alpha_dl,n_particles)\n\nCreates an iterable with the polarizability of all particles in order to facilitate the syntaxis for multuplying a Green function with the polarizability of a particle i\n\nArguments\n\nalpha_dl: polarizability 6x6 tensor, see the Alphas module's documentation for the accepted formats.\nn_particles: number of particles (integer)\n\nOutputs\n\nalp: iterable polarizability\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.renorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.renorm_alpha","text":"renorm_alpha(knorm,alpha)\n\nRenormalizes any polarizability alpha with units of volume in a dimensionless polarizability by multiplying by k^34pi. knorm is the wavenumber in the medium.\n\n\n\n\n\n","category":"method"},{"location":"alphas/","page":"Alphas","title":"Alphas","text":"CoupledElectricMagneticDipoles.Alphas.denorm_alpha(knorm,alpha)","category":"page"},{"location":"alphas/#Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha-Tuple{Any, Any}","page":"Alphas","title":"Main.CoupledElectricMagneticDipoles.Alphas.denorm_alpha","text":"denorm_alpha(knorm,alpha)\n\nDenormalizes any dimensionless polarizability alpha in a polarizability with units of volume by multiplying by 4pi k^3. knorm is the wavenumber in the medium.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#DDA-Core-Functionalities","page":"DDACore","title":"DDA Core Functionalities","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"DDACore is the modules allowing to solve CEMD problems (see the \"Theory\" section for definition of the problem). The problems can be solved either on the CPU (in parrallel with LAPACK) or on the GPU (With CUDA). The list of functions and how to use them is in the next section. Note that N denotes the number of point dipoles in the problem.","category":"page"},{"location":"ddacore/#Functions-List-and-Documentation","page":"DDACore","title":"Functions List and Documentation","text":"","category":"section"},{"location":"ddacore/#Main-Solver-Functions","page":"DDACore","title":"Main Solver Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e","text":"solve_DDA_e(kr,alpha_e_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations under a given input field for a group of N only electric dipoles and returns the incident fields on each of the dipoles. \n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 3, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If `input_field=nothing, the output of the function will be the inverse of the DDA matrix.\nsolver: string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output informations to the standard output during running or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole. if input_field is a 2D array.\nphi_inc: 3D complex array of size N_ftimes Ntimes 3 containing the incident electric field mathbfE_i on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size \"3N\\times 3N\", if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nBuilds and solves the DDA equations with dimensionless inputs under a given input field for a group of N electric and magnetic dipoles and return the polarisations of every particle and incident fields on every particle.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. It can also be a 3D array of size N_ftimes Ntimes 3, allowing to solve the problem for several input fields without re-inverting the matrix. This is a keyword argument. If `input_field=nothing (default value), the output of the function will be the inverse of the DDA matrix.\nsolver:string that contains the name of the solver that need to be used. For this, check the DDACore.solve_system function documentation. By default set to \"CPU\".\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nDepending on the value of input field, it can be:\n\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole, if input_field is a 2D array.\nphi_inc: 3D complex array of size N_ftimes Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole for each input field, if input_field is a 3D array.\nAinv: complex matrix of size \"6N\\times 6N\", if input_field=nothing.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m-Tuple{Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_DDA_e_m","text":"function solve_DDA_e_m(kr,alpha_dl;input_field=nothing,solver=\"CPU\",verbose=true)\n\nSame as solve_DDA_e_m(kr,alpha_e_dl,alpha_m_dl;input_field=nothing,solver=\"CPU\",verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/#Utilities-Functions","page":"DDACore","title":"Utilities Functions","text":"","category":"section"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.solve_system(A,b,solver,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.solve_system-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.solve_system","text":" solve_system(A,b,solver,verbose)\n\nSolves a system of equations of the type Ax=b using the method solver and returns x. x can be a 1D column vector or a 2D matrix. In this second case, the system is going to solve each column of the matrix as a different problem (without re-inverting A). The solver flag can be set to\n\nCPU: In this case, the system is solved using LAPACK on the CPU.\nGPU: In this case, the system is solved using CUSOLVE on the GPU (if available).\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e(kr,alpha_e_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e","text":" load_dda_matrix_e(kr,alpha_e_dl,verbose)\n\nBuilds the electric only DDA matrix A=I-Galpha with dimensionless postitions kr (2D array of size Nx3) and dimensionless polarisabilities alpha_e_dl (see foramt rules in Alphas module). Returns 3Ntimes 3N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-NTuple{4, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_e_dl,alpha_m_dl,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless postitions kr (2D array of size Ntimes 3) and dimensionless electric and magnetic polarisabilities alpha_e_dl and  alpha_m_dl (see format rules in the Alphas module). Returns the 6Ntimes 6N complex DDA matrix.\n\n\n\n\n\n","category":"method"},{"location":"ddacore/","page":"DDACore","title":"DDACore","text":"CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m(kr,alpha_tensor,verbose)","category":"page"},{"location":"ddacore/#Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m-Tuple{Any, Any, Any}","page":"DDACore","title":"Main.CoupledElectricMagneticDipoles.DDACore.load_dda_matrix_e_m","text":" load_dda_matrix_e_m(kr,alpha_tensor,verbose)\n\nBuilds the electric and magnetic DDA matrix A=I-Galpha with dimensionless postitions kr (two dimensional arrays of size Ntimes 3) and dimensionless polarisability alpha_tensor (see format rules in the Alphas module). Return 6Ntimes 6N complex DDA matrix\n\n\n\n\n\n","category":"method"},{"location":"example_PS_sphere/#Total-and-Differential-Scattering-Cross-Sections-of-a-Polystyrene-Sphere","page":"PS Sphere","title":"Total and Differential Scattering Cross Sections of a Polystyrene Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This example aims to teach the user how to use CEMD.jl in only electric mode. For this we will compute the total and differential scattering cross section of a polystyrene (PS) sphere with a radius of 500nm in water. We will then compare it with mie theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Be careful: using the electric DDA a for solving this type of problems is not optimal at all (way to slow and not accurate). The sizes and refractive indices used in this example make the problem converge reasonably well (see last section) and is then a nice figure of merit for this software. If you need to solve the light scattering of a sphere, it is better to use directly Mie theory. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you don't now what a DDA problem is, please first have a look to the theory part.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you want to run this example, copy it or download it on the github (example_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"julia example_PS_sphere.jl\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If you can, it is recommanded to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra and Lebedev are used to perform integrals on the surface of a sphere (Lebedev.jl).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\nusing Lebedev\nusing LinearAlgebra\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_PS_sphere/#Discretizing-the-Sphere","page":"PS Sphere","title":"Discretizing the Sphere","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We then need to start modelizing our particle in water. For, this we start by defining the parameters of the simulation. PS has a refractive index of 1.59 (we consider no absorption, so no imaginary part). For water, it is 1.33. We can then set the dielectric constant of the particle eps and of the medium eps_h using epsilon=n^2. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"##################### Parameters ########################################\n#radius of the sphere\na=250e-9\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute\nN_lambda=10\nlambda_min=1000e-9\nlambda_max=1100e-9\n#wavelengths to compute\nlambdas0=LinRange(1000e-9,1100e-9,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"lambdas0 are the wavelength for which we want to compute the scattering cross section (here between 1000 and 1100nm). We directly computes the wavelength in medium by dividing by the refractive index. Note that we always use the wavenumber in the medium in the software.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then discretize the sphere in small cubes using Geometries.discretize_sphere. The first parameter is the radius of the sphere and the second is the number of cubes to place in the diameter of the sphere (it will set the total number of cubes of the discretized sphere).","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"If N is the number of cubes in the discretized sphere, this function returns a Nx4 array latt, that contains the coordinates of the center of each cube, as well as its filling fraction (If the cube is in the bulk, the filling fractions is 1. If it is on the surface, the filling fraction can be smaller than 1, depending on volume fraction of the sphere really inside the sphere.). It also returns dx, which is the length of the edges of all the cubes.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here for instance, the number of cubes in the discretized sphere is N=720.","category":"page"},{"location":"example_PS_sphere/#Computing-the-Polarizabilities","page":"PS Sphere","title":"Computing the Polarizabilities","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Now that the sphere is discretized, we need to assign to every cube a polarizability. This polarizability is wavelength dependant and then we nee to create an array to store teh results of the cross section cslculations for each wavelength. For this, we use:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"res=zeros(Float64,N_lambda,3)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can then open a loop and computes the polarizability of each cube as follows:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#solves DDA problem for each wavelength\nfor i=1:N_lambda\n    #wavenumber in medium\n    knorm=2*pi/lambdas[i]\n    #computes polarizability for each dipoles using effective dielectric constant \n    alpha=zeros(ComplexF64,n,3,3)\n    for j=1:n\n        eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n        alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\n    end","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Here, we first compute the wavenumber in the medium and then, using the second loop, assign a polarizability to each cube. Alphas.alpha0_parallelepiped computes the quasistatic polarizability tensor (a 3x3 complex matrix with units of volume) of a cube. Here, we use eps_eff, which is the filling fraction-ponderated mean between the dielectric constant inside and outside the medium. Then, we need to apply the radiative correction to the polarizability using Alphas.alpha_radiative. This last function also renormalize the polarizability from units of volume to no dimensions. We need this because the functions to solve the DDA problem require dimensionless inputs (see the home page and the theory part for more information!).","category":"page"},{"location":"example_PS_sphere/#Solving-the-DDA-Problem-and-Computing-the-Total-Scattering-Cross-Sections","page":"PS Sphere","title":"Solving the DDA Problem and Computing the Total Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Before solving the DDA, problem, we need to choose an input field. We will take a x-polarized plane wave propagating along the positive z axis. For this, we use inputFields.plane_wave_e. This functions takes the dimensionless positions kr of the center of the cubes (i.e. the wavenumber times the coordinates array) and outputs a Nx3 array that represent the input field on each of the dipoles.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes input_field, a x-polarized plane-wave propagating along z\n    input_field=InputFields.plane_wave_e(knorm*latt[:,1:3])","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can now solve the DDA problem between all the dipoles using DDACore.solve_DDA_e:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #solves DDA\n    e_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"The solver is set to \"CPU\", that means that the system of linear equations is going to be solved using the CPU and LAPACK, called from julia. This outputs a Nx3 complex array containing the incident field on each dipole. This incident field can the be used to compute the extinction, absorption and scattering total cross sections (sigma_ext sigma_abs sigma_sca) by calling PostProcessing.compute_cross_sections_e.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"    #computes cross section and save it in folder\n    res[i,1:end]=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\nend","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This function is just returning sigma_ext sigma_abs sigma_sca in a float array. This results is directly saved in res, that we created before.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It is now possible to plot the normalized scattering cross section (Q_sca=sigma_scapi a^2) as a function of the vacuum wavelength divided by the radius lambda_0 a. To check that the result we obtain is correct, we compare with Mie theory (using the MieCoeff module). We also plot the error (Q_ext-Q_abs-Q_abs)Q_ext to check tha t the optical theorem, i.e. sigma_ext=sigma_abs+sigma_sca is well fulfilled. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#scattering cross section from the Mie theory\nres_mie=MieCoeff.mie_scattering_cross_section.(2 .*pi./lambdas,a,eps,eps_h;cutoff=50)\n\n#plotting the cross sections using matplotlib\nfig1,ax1=plt.subplots(2,sharex=true)\n#sets axis labels\nax1[1].set_ylabel(L\"Q_{sca}\")\nax1[2].set_ylabel(L\"(Q_{ext}-Q_{abs}-Q_{abs})/Q_{ext}\")\nax1[2].set_xlabel(L\"\\lambda_0/a\")\n#plot\ncst=pi*a^2\nax1[1].plot(lambdas0./a,res[:,3]./cst,color=\"black\",label=\"DDA, N=\"*string(n),marker=\"o\")\nax1[1].plot(lambdas0./a,res_mie./cst,color=\"red\",label=\"Mie\",marker=\"o\")\nax1[2].plot(lambdas0./a,(res[:,1].-res[:,2].-res[:,3])./res[:,1],color=\"black\",marker=\"o\")\n#legend and save\nax1[1].legend()\nplt.tight_layout()\nfig1.savefig(\"Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"This is what we get:","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We see that the DDA cross section is not exactly the same that the Mie one and that the energy is correctly conserved.. For more information, a small convergence study is shown in the last section of this example (without code).","category":"page"},{"location":"example_PS_sphere/#Computing-the-Differential-Scattering-Cross-Sections","page":"PS Sphere","title":"Computing the Differential Scattering Cross Sections","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"In this part of the example, we want to compute the differential scattering cross section in the y-z plane of the same sphere (we fix here the wavelength to be lambdas[1], i.e. 1000nm in vacuum). To start, we just solve the DDA problem and computes cross sections as we did previously.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes polarizability for each dipoles using effective dielectric constant \nknorm=2*pi/lambdas[1]\nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    global  alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\nend\n\n#computes input_field, a x-polarized plane-wave propagating along z\ninput_field=InputFields.plane_wave_e(knorm*latt[:,1:3])\n#solves DDA\ne_inc=DDACore.solve_DDA_e(knorm*latt[:,1:3],alpha,input_field=input_field,solver=\"CPU\")\n#computes cross section\ncs=PostProcessing.compute_cross_sections_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field;explicit_scattering=true,verbose=true)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"Then, we define a array of angle thetas in order to generate a uniform sampling ur of the units vectors in the y-z plane.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#sampling direction an plotting \nthetas=LinRange(0,2*pi,100)\nur=zeros(100,3)\nur[:,3]=cos.(thetas)\nur[:,2]=sin.(thetas)\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"using this array of directions, we can compute the differential cross section in all of these directions using PostProcessing.diff_scattering_cross_section_e. This takes the same positional arguments as PostProcessing.compute_cross_sections_e, but just adding the array of directions. It outputs an array containing the differential scattering cross section in all the directions contained in ur.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#computes differential cross section\nres=PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,ur)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"We can plot it with a radial projection. This time again, we plot the normalized scattering cross section.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#plotting\nfig2=plt.figure()\nax2 = fig2.add_subplot(projection=\"polar\")\nax2.set_title(L\"log(d Q_{sca}/ d \\Omega)\")\nax2.plot(thetas,log10.(res/pi/(a^2)),label=\"y-z plane\")\nfig2.savefig(\"diff_Q_sca.svg\")","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/diff_Q_sca.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"On this plot, the input wave is coming from the left side. We see that most of the light is forward scattered. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"For a sanity check, we can try to integrate the differential scattering cross section on the unit sphere using Lebedev.jl and compare with the total scattering cross section. ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"#Compare total scattering cross section and integral of the differential one\nx,y,z,w = lebedev_by_order(13)\ncsca_int=4 * pi * dot(w,PostProcessing.diff_scattering_cross_section_e(knorm,knorm*latt[:,1:3],e_inc,alpha,input_field,[x y z]))\nprintln(cs[3],\" : \",csca_int)","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"It outputs","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"5.004200684958882e-14 : 5.0042006849097616e-14\n","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"showing, that they are the same.","category":"page"},{"location":"example_PS_sphere/#A-Note-on-Convergence","page":"PS Sphere","title":"A Note on Convergence","text":"","category":"section"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"As seen in the previous sections, the scattering cross section obtained with N=720 cubes/dipoles don't match perfectly with the mie solution (a bit more than 1%). But what happens if we change the number of cubes? We repeated the calculations of the total scattering cross section but with several number of dipoles (from 117 to 9549). Here are the results: ","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"<img src=\"../assets/test_conv.svg\">","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"What we see is that the error starts to be way smaller for numbers of dipoles bigger than 2295. The example of the PS sphere works quite well, but be careful, this doesn't mean that it will converge like that for every types of spheres. If you want to do that with another sphere made of another material or another object, check the convergence!. Recall also that DDA is not the best method to solve light scattering problems by a sphere. If you don't really need it, prefer to use Mie Theory.","category":"page"},{"location":"example_PS_sphere/","page":"PS Sphere","title":"PS Sphere","text":"","category":"page"},{"location":"example_ldos_silver_np/#Local-density-of-states-for-a-metallic-nanoparticle","page":"LDOS Silver Particle","title":"Local density of states for a metallic nanoparticle","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This example aims to teach the user how to use other advanced utilities such as the local density of states (LDOS) by reproducing the results of R. Carminati et. al., Opt. Comm. 261, 368 (2006). The system under study is a silver particle of radius 5 nm around its plasmon-resonance frequency (lambda = 354 nm) and at out-of-resonance (lambda = 612 nm). The numerical projected LDOS is then compared with the analytical results derived in the manuscript.  ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"If you want to run this example, copy it or download it on the github (example_ldos_silver_np.jl) and run it using ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"julia example_ldos_silver_np.jl\n","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use PyCall, because we will use the python matplotlib library in order to plot the results.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_ldos_silver_np/#Defining-analytical-solutions-from-R.-Carminati-et.-al.,-Opt.-Comm.-261,-368-(2006)","page":"LDOS Silver Particle","title":"Defining analytical solutions from R. Carminati et. al., Opt. Comm. 261, 368 (2006)","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Let first define the analytical solution of the LDOS, that it takes as inputs the dimensionless distance kz and polarizability alp_dl, and the outpus are the projected LDOS along the z- and x-axis. By definition, the silver nanoparticle will be placed at the origin of the coordinate system, and the LDOS is measured along the z-axis.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# analytic solution R. Carminati et. al., Opt. Comm. 261, 368 (2006)\nfunction ldos_analytic(kz, alp_dl)\n    ldos_z = 1 + 6*imag(alp_dl*exp(2*im*kz)*(-1/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    ldos_x = 1 + 3/2*imag(alp_dl*exp(2*im*kz)*(1/kz^2 + 2*im/kz^3 - 3/kz^4 - 2*im/kz^5 + 1/kz^6) )\n    return ldos_z, ldos_x\nend","category":"page"},{"location":"example_ldos_silver_np/#Setting-physical-properties","page":"LDOS Silver Particle","title":"Setting physical properties","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Now let's set the parameters of the system, as well as the variables where the LDOS will be stored.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# physical properties\n# particle radius\na = 5e-9 \n# wavelengths\nlamb = [612e-9, 354e-9] \n# dielectric constant of the particle\neps=[-15.04 + im*1.02, -2.03 + im*0.6] \n# distance between particle and dipole \nnz = 91 \nz = LinRange(10,100,nz)*1e-9 ","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"The values of the permittivity is taken directly from the manuscript, that correspond with the permittivity at the specific wavelengths, as can be checked in E.W. Palik, Handbook of Optical Constants of Solids, Academic Press, San Diego, 1985 for bulk silver. ","category":"page"},{"location":"example_ldos_silver_np/#Computing-the-LDOS","page":"LDOS Silver Particle","title":"Computing the LDOS","text":"","category":"section"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"We can then open a loop and computes the LDOS as follows:","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# ldos calculation at both wavelengths and all distances\nfor i=1:2 # loop in wavelength\n    # wavevector\n    k = 2*pi/lamb[i] \n    # permittivity\n    eps_i = eps[i] \n    # calculation of the polarizability\n    alp_0 = 4*pi*a^3*(eps_i - 1)/(eps_i + 2) # static polarizability\n    alp = alp_0/(1 - im*k^3/(6*pi)*alp_0) # radiative correction to the polarizability\n    alp_e_dl = alp*k^3/(4*pi) # dimensionless polarizability\n    for j=1:nz # loop in distance\n        # distance\n        z_j = z[j] \n        # renormalized distance\n        kz = k*z_j\n        # renormalized position of the particle (at the origin of coordinates) \n        kr = zeros(1,3) \n        # renormalized position of the diple (z-component at kz)\n        krd = zeros(1,3) \n        krd[3] = kz\n        # analytic ldos\n        global ldos_z_analytic[j,i], ldos_x_analytic[j,i] =  ldos_analytic(kz, alp_e_dl) \n        # numerical ldos\n        Ainv = DDACore.solve_DDA_e(kr,alp_e_dl) # calculation inverse dda matrix\n        global ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 3) # ldos z-axis\n        global ldos_x[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = 1) # ldos x-axis\n    end\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"Here, the polarizability has been calculated using Eq. 5-6 of the manuscript. The selection of the projection of the LDOS is done by the dip argument. It is also possible to pass an array as an argument, defining the dipole moment of the testing dipolar source as","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"dip_vec = zeros(3)\ndip_vec[3] = 1 \nglobal ldos_z[j,i] = PostProcessing.ldos_e(kr, alp_e_dl, Ainv, krd, dip = dip_vec) # ldos z-axis","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This way of calculating the projection along the z-axis would lead into the same result. Also, dip could be any three (of six for electric and magnetic dipoles) dimensional vector.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"It is now possible to plot the LDOS, comparing the numerical and analytical calculations. The plot is made using the python library matplotlib called in julia by the intermediate of the PyCall library, but you can plot it with any software of your choice.","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"# plot ldos\nfor ind_l = 1:2\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSx lambda = \"*string(Int(lamb[ind_l]*1e9))*\" nm\")\n    axs.plot(z*1e9,ldos_x_analytic[:,ind_l],\"--\",label=\"LDOSx analytic\")\n    axs.plot(z*1e9,ldos_x[:,ind_l],\"o\",label=\"LDOSx DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_x\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSx\"*string(Int(lamb[ind_l]*1e9))*\".png\")\n\n    fig,axs=plt.subplots()\n    fig.suptitle(\"LDOSz lambda = \"*string(Int(lamb[ind_l]*1e9))*\" nm\")\n    axs.plot(z*1e9,ldos_z_analytic[:,ind_l],\"--\",label=\"LDOSz analytic\")\n    axs.plot(z*1e9,ldos_z[:,ind_l],\"o\",label=\"LDOSz DDA\")\n    axs.set_xlabel(\"z (nm)\")\n    axs.set_ylabel(\"LDOS_z\")\n    axs.set_yscale(\"log\")\n    fig.tight_layout()\n    axs.legend()\n    plt.savefig(\"LDOSz\"*string(Int(lamb[ind_l]*1e9))*\".png\")\nend","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"This is what we get:","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz354.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSx612.svg\">","category":"page"},{"location":"example_ldos_silver_np/","page":"LDOS Silver Particle","title":"LDOS Silver Particle","text":"<img src=\"../assets/LDOSz612.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Electromagentic-forces-of-a-Gaussian-Beam-on-a-Polystyrene-Sphere","page":"Optical Trap","title":"Electromagentic forces of a Gaussian Beam on a Polystyrene Sphere","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"This example aims to teach the user how to calculate optical forces, as well as to calculate the field and its derivatives of a tight-focused Gaussian beam. Note that the derivaties are implemented as adimensional. Thus, both the field and the derivatives would have the same units.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"The forces will be calculated along the three axes, x-, y- and z-axis. For example, for the forces along the x-axis, we will take y = z = 0 (and the same for the other axis). Also, with the forces along a given axis, we mean that the input field is a Gaussian beam focus at the origin of coordinates, while the force is calculated as a function of the position of the center of the Polystyrene Sphere. Nonetheless, in order to avoid the recalculation of the DDA matrix, in the calculation the particle is fixed at the center of coordinates, while the focus of the Gaussian Beam is moving.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"If you want to run this example, copy it or download it on the github (example_force_gaussbeam_PS_sphere.jl) and run it using ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"julia example_force_gaussbeam_PS_spher.jl\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"If you can, it is recommended to run it in parallel, using the --threads option. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Let's start by importing CoupledElectricMagneticDipoles.jl. Note that we also use LaTeXStrings and PyCall, because we will use the python matplotlib library in order to plot the results. LinearAlgebra is used for....","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"#imports\nusing CoupledElectricMagneticDipoles\nusing PyCall\nusing LaTeXStrings\n#using DelimitedFiles \n@pyimport matplotlib.pyplot as plt\n","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Discretizing-the-Sphere-and-polarizability","page":"Optical Trap","title":"Discretizing the Sphere and polarizability","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"We then need to start modeling our particle in water. The parameters are the same used for example_PS_sphere.jl. Thus, please visit this example for more details.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"##################### Parameters ########################################\n#radius of the sphere\na=250e-9\n#dielectric constant of the particle\neps=(1.59)^2\n#dielectric constant of the medium\neps_h=(1.33)^2\n#number of wavelengths to compute\nN_lambda=10\nlambda_min=1000e-9\nlambda_max=1100e-9\n#wavelengths to compute\nlambdas0=LinRange(1000e-9,1100e-9,N_lambda)\nlambdas=lambdas0/sqrt(eps_h)\n##########################################################################\n\n#discretizes a sphere in small cubes\nlatt,dx=Geometries.discretize_sphere(a,10)\nn=length(latt[:,1])\n\n# Parameters for the forces at lambda_0 = 1000 nm\n# wavelength\nlamb = lambdas[1]\n# wavevector\nknorm=2*pi/lamb\n# renormalized distance of the dipoles\nkr = knorm*latt[:,1:3]\n\n#computes polarizability for each dipoles using effective dielectric constant \nalpha=zeros(ComplexF64,n,3,3)\nfor j=1:n\n    eps_eff=latt[j,4]*eps+(1-latt[j,4])*eps_h\n    alpha[j,:,:]=Alphas.alpha_radiative(Alphas.alpha0_parallelepiped(dx,dx,dx,eps_eff,eps_h),knorm)\nend\n# calculation of the inverse DDA matrix\nAinv = DDACore.solve_DDA_e(kr,alpha)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Note that in this example DDACore.solve_DDA_e has no input_field argument. Then, the output is the inverse DDA matrix. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Setting-incoming-field-and-particle-position","page":"Optical Trap","title":"Setting incoming field and particle position","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"As an incoming field, we will use a Gaussian Beam with radius beam waist w0 = \\lambda/2, and intensity at the focus I0 = 25 GW/m^2. Also, the forces will be calculated along the three axes, between [-2\\lambda, 2\\lambda], discretizing the space in 51 points. For convenience, it is better to use an odd number of points in order to take the 0.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# parameters of the Gaussian Beam\n# radius beam waist\nbw0 = lamb/2\n# intensity at focus (25 GW/m^2)\nintensity = 25e9\n# electromagnetic constants\neps0 = 8.8541878128e-12\nc_const = 3e8\n# electric field amplitude at focus (V/m)\ne0 = sqrt(2*intensity/c_const/eps0/eps_h)\n\n# discretization of the position of the particle\nndis = 51 # odd number in order to mesh the \"0\" position\ndis = LinRange(-2*lamb,2*lamb,ndis)\n# variable where the force will be stored\nforce = zeros(ndis,3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"For knowing what is the field distribution of this field, the file example_plot_gauss_beam.jl can be runned.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-the-forces","page":"Optical Trap","title":"Calculating the forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Finally, we can then open a loop and computes the forces as follow:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# loop on distances \n# note that, instead of moving the particle (and avoiding to recalculate the inverse DDA matrix), the position of the focus \n# of the Gaussian beam is changed.\nfor i=1:ndis \n    # forces along the x-axis when the particle is moving along the same axis (with y = z = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    rf = latt[:,1:3] .+ [dis[i] 0 0]\n    e_0inc = InputFields.gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(knorm,kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,1] = sum(fx)\n\n    # forces along the y-axis when the particle is moving along the same axis (with z = x = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    rf = latt[:,1:3] .+ [0 dis[i] 0]\n    e_0inc = InputFields.gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    # calculation of forces \n    fx, fy, fz = Forces.force_e(knorm,kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,2] = sum(fy)\n\n    # forces along the z-axis when the particle is moving along the same axis (with x = y = 0)\n    # evaluation of the Gaussian beam and its derivatives \n    rf = latt[:,1:3] .+ [0 0 dis[i]]\n    e_0inc = InputFields.gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    dxe_0inc, dye_0inc, dze_0inc = InputFields.d_gauss_beam_e(rf,knorm,bw0,e0 = e0)\n    # calculation of forces\n    fx, fy, fz = Forces.force_e(knorm,kr,alpha, Ainv, e_0inc, dxe_0inc, dye_0inc, dze_0inc)\n    global force[i,3] = sum(fz)\nend\n#=\n# save data\nfout=open(\"dis.dat\",\"w\")\nwritedlm(fout,dis)\nclose(fout)\nfout=open(\"force.dat\",\"w\")\nwritedlm(fout,force)\nclose(fout)\n=#","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"As it is explained above, for the calculation the Polystyrene Sphere is keeped at the origin of coordinates, while the focus of the derivatives beam is changed. However, (for reciprocity) we interpret the results as the forces on the Polystyrene Sphere as it is moving out the focus. ","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"To save the data, uncomment the last lines and include \"using DelimitedFiles\".","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Calculating-stiffnesses","page":"Optical Trap","title":"Calculating stiffnesses","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Since the tight-focused Gaussian beam is going to trap the particle, the forces around the equilibrium position can be approximated by a linear model. The depth of the trap can be characterized by the stiffnesses along the different axis, a simple spring model. To estimate the stiffnesses, a linear fit can be done.","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# calculation of the stiffnesses of the trap by a linear fit around the zero force position\n# for kx and ky, we directly assume that the zero force position is at the minimum of the \"dis\" array (at dis = 0)\n# find the position of the minimum\nval, ind_min_xy = findmin(abs.(dis))\n# calculation of the stiffnesses along the x- and y-axis\nkx = -(force[ind_min_xy+1,1]-force[ind_min_xy-1,1])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\nky = -(force[ind_min_xy+1,2]-force[ind_min_xy-1,2])/(dis[ind_min_xy+1] - dis[ind_min_xy-1])\n# for kz the minimum is found as the first minimum along the z-axis (the minimum is not at \"z=0\")\nind_min_z = ind_min_xy\nwhile abs(force[ind_min_z,3]) > abs(force[ind_min_z+1,3])\n    min_z = ind_min_z + 1\n    global ind_min_z = min_z\nend\n# calculation of the stiffnesses along the z-axis\nkz = -(force[ind_min_z+1,3]-force[ind_min_z-1,3])/(dis[ind_min_z+1] - dis[ind_min_z-1])\n# linear calculation of for the position of the minimum\nzmin = dis[ind_min_z] + force[ind_min_z,3]/kz\n# shorter array for plotting the linear approximation of the forces\ndis_short = LinRange(-lamb/4,lamb/4,ndis)\n# linear approximation of the force around the zero\nfx_lin = -kx*dis_short\nfy_lin = -ky*dis_short\nfz_lin = -kz*(dis_short)\n# rounding the value of the stiffnesses for the legend\nkx = round(kx*1e6,sigdigits=3)\nky = round(ky*1e6,sigdigits=3)\nkz = round(kz*1e6,sigdigits=3)","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/#Plotting-forces","page":"Optical Trap","title":"Plotting forces","text":"","category":"section"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"Once the forces and the stiffnesses are calculated, they can be plotted using the next lines:","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"# plotting results\nfig, axs = plt.subplots()\naxs.set_title(L\"x-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,1]*1e15,label=\"\")\naxs.plot(dis_short*1e9,fx_lin*1e15,\"--\",label=\"kx = \"*string(kx)*\" fN/nm\")\naxs.set_xlabel(\"x (nm)\")\naxs.set_ylabel(\"Fx (fN)\")\naxs.legend()\nfig.savefig(\"fx.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"y-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,2]*1e15)\naxs.plot(dis_short*1e9,fy_lin*1e15,\"--\",label=\"ky = \"*string(ky)*\" fN/nm\")\naxs.set_xlabel(\"y (nm)\")\naxs.set_ylabel(\"Fy (fN)\")\naxs.legend()\nfig.savefig(\"fy.svg\")\n\nfig, axs = plt.subplots()\naxs.set_title(L\"z-axis, \\lambda_0 = 1000 nm, \\lambda = \\lambda_0/1.33, w0 = \\lambda/ 2, I_0 = 25 GW/m^2\")\naxs.plot(dis*1e9,force[:,3]*1e15)\naxs.plot((dis_short .+ zmin)*1e9,fz_lin*1e15,\"--\",label=\"kz = \"*string(kz)*\" fN/nm\")\naxs.plot(dis*1e9,force[:,3]*0,\"k--\")\naxs.set_xlabel(\"z (nm)\")\naxs.set_ylabel(\"Fz (fN)\")\naxs.legend()\nfig.savefig(\"fz.svg\")","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fx.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fy.svg\">","category":"page"},{"location":"example_force_gaussbeam_PS_sphere/","page":"Optical Trap","title":"Optical Trap","text":"<img src=\"../assets/fz.svg\">","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"\n<embed type=\"application/pdf\" src=\"../assets/CoupledElectricMagneticDipoles.pdf\" width=\"1000\" height=\"100%\" </embed>\n\n<p>This browser does not support PDFs? Please download the PDF to view it: <a href=\"../assets/CoupledElectricMagneticDipoles.pdf\">Download PDF</a>.</p>","category":"page"},{"location":"miecoeff/#Mie-Coefficients","page":"MieCoeff","title":"Mie Coefficients","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"MieCoeff is a small modules to compute Mie Coefficients, mostly to use it to compute polarizabilities. It also contains some useful function to compute cross sections from the Mie theory. ","category":"page"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"Expressions are taken in Craig F. Bohren, Donald R. Huffman, Absorption and Scattering of Light by Small Particles (1998).","category":"page"},{"location":"miecoeff/#Functions-Documentation","page":"MieCoeff","title":"Functions Documentation","text":"","category":"section"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_an(vac_knorm, a, eps, eps_h,n)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an-NTuple{5, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_an","text":"mie_an(knorm, a, eps, eps_h, n)\n\nComputes the n-th mie coefficient a_n of a sphere of radius a with dielectric constant eps, in a medium with dielectric constant eps_h. knorm is wavenumber in the medium.  Retruns a complex scalar.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_bn(vac_knorm, a, eps, eps_h, n)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn-NTuple{5, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_bn","text":"mie_bn(knorm, a, eps, eps_h, n)\n\nComputes the n-th mie coefficient b_n of a sphere of radius a with dielectric constant eps, in a medium with dielectric constant eps_h. knorm is wavenumber in the medium. Returns a complex scalar. \n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section(knorm,a,eps,eps_h;cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_scattering_cross_section","text":"mie_scattering_cross_section(knorm,a,eps,eps_h;cutoff=20)\n\nComputes the scattering cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_sca =frac2pik^2sum^infty_n=1left(2n+1right)left(a_n^2+b_n^2right)\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 20).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section(knorm,a,eps,eps_h;cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_extinction_cross_section","text":"mie_extinction_cross_section(knorm,a,eps,eps_h;cutoff=20)\n\nComputes the extinction cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_ext =frac2pik^2sum^infty_n=1left(2n+1right)Releft(a_n+b_nright)\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 20).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"},{"location":"miecoeff/","page":"MieCoeff","title":"MieCoeff","text":"CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section(knorm,a,eps,eps_h;cutoff=20)","category":"page"},{"location":"miecoeff/#Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section-NTuple{4, Any}","page":"MieCoeff","title":"Main.CoupledElectricMagneticDipoles.MieCoeff.mie_absorption_cross_section","text":"mie_absorption_cross_section(knorm,a,eps,eps_h;cutoff=20)\n\nComputes the extinction cross section C_sca of a sphere of radius a with dielectric constant eps in a medium with dielectric constant eps_h. knorm is the wavenumber in the medium. For this, we use:\n\nC_abs =C_ext-C_sca\n\nThe infinite sum is computed only for terms under the cutoff variable (by default set to 20).\n\nReturns a float with units of surface.\n\n\n\n\n\n","category":"method"},{"location":"forces/#Optical-Forces","page":"Forces","title":"Optical Forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"The Forces module allows to computes optical forces aon electric and magnetic dipoles with deterministic input fields. The list of functions is below. Note that N is the number of dipoles in the system. ","category":"page"},{"location":"forces/#Functions-Documentation","page":"Forces","title":"Functions Documentation","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e(knorm,kr,alpha_e_dl, Ainv, e_0, dxe_0, dye_0, dze_0)","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e-NTuple{8, Any}","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e","text":"force_e(knorm,kr,alpha_e_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric dipoles for deterministic input fields.\n\n#Arguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 3 containing the external imput field.\ndxe_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*x argument of the external imput field.\ndye_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*y argument of the external imput field.\ndze_0: 2D complex array of size Ntimes 3 containing the derivative respect the k*z argument of the external imput field.\n\n#Outputs\n\nreal(fx): float array of Size N with the value of the force along the x-axis at each dipole.\nreal(fy): float array of Size N with the value of the force along the y-axis at each dipole.\nreal(fz): float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\n","category":"method"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m(k,kr,alpha_dl, Ainv, e_0, dxe_0, dye_0, dze_0)","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e_m-NTuple{8, Any}","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e_m","text":"force_e_m(k,kr,alpha_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nSame as force_e_m(knorm,kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"forces/","page":"Forces","title":"Forces","text":"CoupledElectricMagneticDipoles.Forces.force_e_m(knorm,kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0)","category":"page"},{"location":"forces/#Main.CoupledElectricMagneticDipoles.Forces.force_e_m-NTuple{9, Any}","page":"Forces","title":"Main.CoupledElectricMagneticDipoles.Forces.force_e_m","text":"force_e_m(knorm,kr,alpha_e_dl, alpha_m_dl, Ainv, e_0, dxe_0, dye_0, dze_0)\n\nComputes the optical forces on a system made out of electric and magnetic dipoles for deterministic input fields.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\ne_0: 2D complex array of size Ntimes 6 containing the external imput field.\ndxe_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*x argument of the external imput field.\ndye_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*y argument of the external imput field.\ndze_0: 2D complex array of size Ntimes 6 containing the derivative respect the k*z argument of the external imput field.\n\nOutputs\n\nreal(fx): float array of Size N with the value of the force along the x-axis at each dipole.\nreal(fy): float array of Size N with the value of the force along the y-axis at each dipole.\nreal(fz): float array of Size N with the value of the force along the z-axis at each dipole.\n\n\n\n\n\n","category":"method"},{"location":"geometries/#Geometries-library","page":"Geometries","title":"Geometries library","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"Geometries is a small modules allowing to discretize primitives in small cubes, that can be later used in the DDA. The two primitives that are proposed are a sphere and a cube. The description of the two functions are given in the next section. Note that the discretization of the sphere implements anti-aliasing (see Wikipedia page for anti-aliasing or the PS sphere example).","category":"page"},{"location":"geometries/#Functions-Documentation","page":"Geometries","title":"Functions Documentation","text":"","category":"section"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_sphere","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_sphere","text":"discretize_sphere(a,N;N_sub=10)\n\nDiscretizes the volume of a sphere of radius a in small cubes of edge dx=2*a/N. N_sub is a parameter to set the anti-aliasing accuracy of the discretisation. It is by default set to 10. If N_d is the obtained number of cubes, the output is a N_d times 4 array containing the 3D position of the centers of the cubes and their filling fraction. Returns as well the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"function"},{"location":"geometries/","page":"Geometries","title":"Geometries","text":"CoupledElectricMagneticDipoles.Geometries.discretize_cube(L,N)","category":"page"},{"location":"geometries/#Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube-Tuple{Any, Any}","page":"Geometries","title":"Main.CoupledElectricMagneticDipoles.Geometries.discretize_cube","text":"discretize_cube(L,N)\n\nDiscretizes the volume of a cube of edge L in small cubes of edge dx=L/N. If N_d is the obtained number of cubes, the output is a N_d times 4 array containing the 3D position of the centers of the cubes and their filling fraction (i.e. 1). Returns as well the size of the edge of the cubes dx.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Post-Processing","page":"PostProcessing","title":"Post Processing","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The PostProcessing modules allows you to process the results of a CEMD calculation. Mostly for:","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"Computing cross sections and differential emitted power. \nComputing scattered fields.\nComputing local density of states (LDOS).","category":"page"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"The list of functions and a description of how to use them is given in the following section. In general N represents the number of dipoles.","category":"page"},{"location":"postprocessing/#Functions-List-and-Documentation","page":"PostProcessing","title":"Functions List and Documentation","text":"","category":"section"},{"location":"postprocessing/#Functions-for-Cross-Sections-and-Differential-Emitted-Power","page":"PostProcessing","title":"Functions for Cross Sections and Differential Emitted Power","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e(knorm,kr,e_inc,alpha,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e","text":"compute_cross_sections_e(knorm,kr,e_inc,alpha_e_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric dipoles, in a plane wave input field. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it must be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true)\n\nComputes the extinction, absorbtion and scattering cross section sigma_ext, sigma_abs, sigma_sca of a system made out of electric and magnetic dipoles, in a plane wave input field. Note that it should follow the optical theorem, i.e.\n\nsigma_ext=sigma_abs+sigma_sca\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nexplicit_scattering: boolean that says whether to compute scttering cross section explicitely (true) or to deduce it from the optical theorem (false). By default set to true.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\na float array of length 3 containing in order: extinction, absorption and scattering cross section.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_cross_sections_e_m","text":"compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_dl,input_field;explicit_scattering=true,verbose=true)\n\nSame as compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e","text":"diff_scattering_cross_section_e(knorm,kr,e_inc,alpha_e_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric dipoles in direction(s) ur.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 3 containing the electric input field mathbfE_0(mathbfr_i) at the position of each dipole. Note that it should be a plane wave\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r where the diffrential scattering cross section is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field,ur;verbose=true)\n\nComputes the differential scattering cross section d sigma_sca dOmega of a system made out of electric and magnetic dipoles in direction(s) ur.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole. Note that it should be a plane wave.\nur: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r where the diffrential scattering cross section is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential cross section in each direction.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_scattering_cross_section_e_m","text":"diff_scattering_cross_section_e_m(knorm,kr,phi_inc,alpha_dl,input_field,ur;verbose=true)\n\nSame as compute_cross_sections_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,input_field;explicit_scattering=true,verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e(knorm,kr,e_inc,alpha_e_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e","text":"diff_emitted_power_e(knorm,kr,e_inc,alpha_e_dl,krf,phi_inp_krf;verbose=true)\n\nComputes the differential emitted power d P dOmega of a system made out of electric dipoles in direction(s) of position(s) krf.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole.\nkrf: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r in which direction the diffrential emitted power is computed. Note that the magnitude of these position must be way bigger than the dipoles positions.\nphi_inp_krf: like input_field, but evaluated at the krf positions.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in direction directions.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m-NTuple{7, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m","text":"diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)\n\nComputes the differential emitted power d P dOmega of a system made out of electric and magnetic dipoles in direction(s) of position(s) krf.\n\nArguments\n\nknorm: wavenumber in the medium.\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\ninput_field: 2D complex array of size Ntimes 6 containing the electric and magnetic input field mathbfphi=(mathbfE_0(mathbfr_i)mathbfH_0(mathbfr_i)) at the position of each dipole.\nkrf: 1D float vector of length 3 (only one direction) or 2D float array of size Nutimes 3 (more thant 1 directions) containing the dimensionless positions kmathbfu_r in which direction the diffrential emitted power is computed. Note that the magnitude of these position must be way bigger than the dipoles positions.\nphi_inp_krf: like input_field, but evaluated at the krf positions.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nan array containing the differential emitted power in direction directions.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_dl,krf,phi_inp_krf;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m-NTuple{6, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.diff_emitted_power_e_m","text":"diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true)\n\nSame as diff_emitted_power_e_m(knorm,kr,phi_inc,alpha_e_dl,alpha_m_dl,krf,phi_inp_krf;verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-Scattered-Fields","page":"PostProcessing","title":"Functions for Scattered Fields","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e(kr, alpha_e_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e","text":"function field_sca_e(kr, alpha_e_dl, e_inc, krf)\n\nComputes the scattered field from a system made out of electric dipoles.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf; verbose=true)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m(kr, alpha_dl, e_inc, krf; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.field_sca_e_m","text":"field_sca_e_m(kr, alpha_dl, phi_inc, krf)\n\nSame as field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e(kr, alpha_e_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e","text":"function far_field_sca_e(kr,e_inc,alpha_e_dl,krf)\n\nComputes the scattered field from a system made out of electric dipoles in the far field approximation.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\ne_inc: 2D complex array of size Ntimes 3 containing the incident electric field mathbfE_i on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_e_dl,alpha_m_dl,krf)\n\nComputes the scattered field from a system made out of electric and magnetic dipoles in the far field approximation.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole. Note that these positions have to be far away from the dipoles positions.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nphi_inc: 2D complex array of size Ntimes 6 containing the incident electric and magnetic field mathbfphi=(mathbfE_imathbfH_i) on each dipole.\nkrf: 1D float vector of length 3 (only one position) or 2D float array of size Nutimes 3 (more thant 1 position) containing the dimensionless positions kmathbfr_f at which the scattered field is computed.\n\nOutputs\n\nfield_r: 2D complex array of size Nftimes 6 containing the scattered field by the dipoles at every kmathbfr_f.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m(kr, alpha_dl, e_inc, krf)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.far_field_sca_e_m","text":"function far_field_sca_e_m(kr,e_inc,alpha_dl,krf)\n\nSame as far_field_sca_e_m(kr, alpha_e_dl, alpha_m_dl, phi_inc, krf), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Functions-for-LDOS","page":"PostProcessing","title":"Functions for LDOS","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e","text":"ldos_e(kr, alpha_e_dl, Ainv, krd; dip=nothing, verbose=true)\n\nIt Computes local density of states (LDOS) of a system made out of electric dipoles by the imaginary part of the returning field.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 3 with the desired dipole moment of the dipole.  \nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing;verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{5, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true)\n\nComputes local density of states (LDOS) of a system made out of electric and magnetic dipoles by taking the imaginary part of the returning field.\n\nArguments\n\nkr: 2D float array of size Ntimes 3 containing the dimensionless position kmathbfr of each dipole.\nalpha_e_dl: complex dimensionless electric polarizability of each dipole. See the Alphas module documentation for accepted formats.\nalpha_m_dl: complex dimensionless magnetic polarizability of each dipole. See the Alphas module documentation for accepted formats.\nAinv: (inverse) DDA matrix.\nkrd: 2D float array of size Ndtimes 3 containing the dimentionless positions kmathbfr_d where the LDOS is calculated.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or float array of size 6 with the desired dipole moment of the dipole.  \nverbose: whether to output pieces of information to the standard output during running or not. By default set to true.\n\nOutputs\n\nLDOS: float array with the LDOS.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing; verbose=true)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m-NTuple{4, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.ldos_e_m","text":"ldos_e_m(kr, alpha_dl, Ainv, krd; dip=nothing, verbose=true)\n\nSame as ldos_e_m(kr, alpha_e_dl, alpha_m_dl, Ainv, krd; dip=nothing, verbose=true), but the electric and magnetic polarizabilities of each dipole are given by a single 6x6 complex matrix.  See the Alphas module documentation for accepted formats.\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/#Utilities-Functions","page":"PostProcessing","title":"Utilities Functions","text":"","category":"section"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment(alpha,phi_inc)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment-Tuple{Any, Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.compute_dipole_moment","text":"compute_dipole_moment(alpha,phi_inc)\n\nComputes the dipole moment (magnetic or electric) of a dipole with polarizability alpha under an incident field phi_inc. alpha can be:\n\na complex scalar\na 1D complex array of size N\na 3times 3 or 6times 6 complex matrix.\na 3D complex array of size Ntimes 3times 3 or Ntimes 6times 6\n\n\n\n\n\n","category":"method"},{"location":"postprocessing/","page":"PostProcessing","title":"PostProcessing","text":"CoupledElectricMagneticDipoles.PostProcessing.poynting_vector(phi)","category":"page"},{"location":"postprocessing/#Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector-Tuple{Any}","page":"PostProcessing","title":"Main.CoupledElectricMagneticDipoles.PostProcessing.poynting_vector","text":"poynting_vector(phi)\n\nComputes the poynting vector of an electromagnetic field. Input is an electric and magnetic field phi(1D complex Array of length 6). Outputs a 1D float array of length 3.\n\n\n\n\n\n","category":"method"},{"location":"green/#Green-Tensors","page":"GreenTensors","title":"Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"GreenTensors is aimed to compute the renormalized electric and magnetic green tensors. To learn more about the renormalization and the expressions that are used, see the theory part.","category":"page"},{"location":"green/#Functions-Documentation","page":"GreenTensors","title":"Functions Documentation","text":"","category":"section"},{"location":"green/#Renormalized-Green-Tensors","page":"GreenTensors","title":"Renormalized Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_e_renorm","text":"G_e_renorm(kr1,kr2)\n\nComputes the renormalized electric green tensor between two position r1 and r2, where the imputs are the positions multiplied by the wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_m_renorm","text":"G_m_renorm(kr1,kr2)\n\nComputes the renormalized magnetic green tensor between two position r1 and r2, where the imputs are the positions multiplied by the wave number kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_renorm","text":"G_em_renorm(kr1,kr2)\n\nComputes the renormalized electric and magnetic green tensors between two position r1 and r2, where the imputs are the positions multiplied by the wave number kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.G_em_far_field_renorm","text":"G_em_far_field_renorm(kr1,kr2)\n\nComputes the renormalized electric and magnetic green tensors in the far field approximation between two dimensionless position kr1 and kr2. Note that is is only valid for kr_1kr_2 and kr_11 The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/#Derivatives-of-the-Renormalized-Green-Tensors","page":"GreenTensors","title":"Derivatives of the Renormalized Green Tensors","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_e_renorm","text":"dxG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric green tensor (defined in G_e_renorm(kr1,kr2)) regarding the k*x component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_e_renorm","text":"dyG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric green tensor (defined in G_e_renorm(kr1,kr2)) regarding the k*y component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_e_renorm","text":"dzG_e_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric green tensor (defined in G_e_renorm(kr1,kr2)) regarding the k*z component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_m_renorm","text":"dxG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic green tensor (defined in G_m_renorm(kr1,kr2)) regarding the k*x component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_m_renorm","text":"dyG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic green tensor (defined in G_m_renorm(kr1,kr2)) regarding the k*y component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_m_renorm","text":"dzG_m_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized magnetic green tensor (defined in G_m_renorm(kr1,kr2)) regarding the k*z component of kr1 between two position  kr1 and kr2. The output is a dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dxG_em_renorm","text":"dxG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic green tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the k*x component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dyG_em_renorm","text":"dyG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic green tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the k*y component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.dzG_em_renorm","text":"dzG_em_renorm(kr1,kr2)\n\nComputes the derivative of the renormalized electric and magnetic green tensors (defined in G_e_renorm(kr1,kr2) and G_m_renorm(kr1,kr2)) regarding the k*z component of kr1 between two position  kr1 and kr2. The outputs are two dimensionless 3x3 complex matrix.\n\n\n\n\n\n","category":"function"},{"location":"green/#Utilities-Functions","page":"GreenTensors","title":"Utilities Functions","text":"","category":"section"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_e","text":"denormalize_G_e(Ge,knorm)\n\nPasses from a dimensionless electric green tensor Ge to a green tensor with units of length⁻¹. knorm is the wavenumber into the medium.\n\n\n\n\n\n","category":"function"},{"location":"green/","page":"GreenTensors","title":"GreenTensors","text":"CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","category":"page"},{"location":"green/#Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","page":"GreenTensors","title":"Main.CoupledElectricMagneticDipoles.GreenTensors.denormalize_G_m","text":"denormalize_G_m(Gm,knorm)\n\nPasses from a dimensionless magnetic green tensor Gm to a green tensor with units of length⁻². knorm is the wavenumber into the medium.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Input-Fields","page":"InputFields","title":"Input Fields","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"This module allows to compute input fields. It also implements derivatives of some of the beams. See the theory part to know more about the expression used tu compute the input fields. In general N represents the number of positions inputed in the function. ","category":"page"},{"location":"input_fields/#Functions-Documentation","page":"InputFields","title":"Functions Documentation","text":"","category":"section"},{"location":"input_fields/#Plane-Waves","page":"InputFields","title":"Plane Waves","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e","text":"plane_wave_e(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at krf. khat is the direction of propagation and e0 is the polarization. krf is a Ntimes 3 float array.  The output is a Ntimes 3 complex array representing the electric field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.plane_wave_e_m","text":"plane_wave_e_m(krf;khat=[0,0,1],e0=[1,0,0])\n\nComputes a simple plane with dimensionless input evaluated at krf. khat is the direction of propagation and e0 is the polarization. krf is a Ntimes 3 float array.  The output is a Ntimes 6 complex array representing the electric and magnetic fields.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Point-Dipoles-Sources","page":"InputFields","title":"Point Dipoles Sources","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e","text":"point_dipole_e(krf, krd, dip, e0_const=1)\n\nComputes the electric field emitted by a point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or complex array of size 6 with the desired dipole moment of the dipole.  \ne0: scalar with the modulus of the dipole moment. \n\nOutputs\n\ne_dipole:2D Ntimes 3 complex array with the electromagnetic field.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.point_dipole_e_m","text":"point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the electric and magnetic fields emitted by a point dipole.\n\nArguments\n\nkrf: 2D float array of size Ntimes 3 containing the dimensionless positions kmathbfr where the field is computed.\nkrd: 1D float array of size 3 containing the dimensionless position kmathbfr_d where source is located.\ndip: integer defining the dipole moment (dip = 1 is an electric x-dipole, dip = 2 an elctric y-dipole...) or complex array of size 6 with the desired dipole moment of the dipole.  \ne0: scalar with the modulus of the dipole moment. \n\nOutputs\n\nphi_dipole: 2D Ntimes 6complex array with the electromagnetic fields at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Gaussian,-Hermite-Gaussian-and-Laguerre-Gaussian-Beams","page":"InputFields","title":"Gaussian, Hermite-Gaussian and Laguerre-Gaussian Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e","text":"gauss_beam_e(rf,knorm,bw0; e0 = 1, kmax = nothing, maxe = Int(5e3))\n\nComputes the electric field distribution of a Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the xy-plane. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\ne0: scalar with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\neh_gauss: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e","text":"ghermite_beam_e(rf,knorm,bw0,n,m; e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electric field distribution of a Hermite-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the xy-plane. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\nn: int with the order of the beam.\nm: int with the degree of the beam.\ne0: scalar with the modulus of the electric field (see theory for more details). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\neh_hermite: 2D complex array of size Ntimes 6 with the value of the field ateach position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e","text":"glaguerre_beam_e(rf,knorm,bw0,n,m; e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electric field distribution of a Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the xy-plane. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\nn: non-negative int with the radial order of the beam.\nm: int with the azimuthal order of the beam.\ne0: scalar with the modulus of the electric field (see theory for more details). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\neh_laguerre: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.gauss_beam_e_m","text":"gauss_beam_e_m(rf, knorm, bw0; e0 = 1, kmax = nothing, maxe = Int(5e3))\n\nComputes the electromagnetic field distribution of a Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\ne0: scalar with the modulus of the electric field at the origin of coordinates of the theoretical field (including evanescent waves). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\nphi_gauss: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.ghermite_beam_e_m","text":"ghermite_beam_e_m(rf,knorm,bw0,n,m; e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electromagnetic field distribution of a Gaussian-Hermite beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the xy-plane. Also, for a polarized magnetic field, exchange E with ZH and H with -E. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\nn: int with the order of the beam.\nm: int with the degree of the beam.\ne0: scalar with the modulus of the electric field (see theory for more details). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\nphi_hermite: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.glaguerre_beam_e_m","text":"glaguerre_beam_e_m(rf,knorm,bw0,n,m; e0 = 1, kmax = nothing, maxe=Int(5e3))\n\nComputes the electromagnetic field distribution of a Laguerre-Gaussian beam that propagates along the z-axis and where the electric field is polarized along the x-axis (polarized electric). For another polarization just rotate the field in the .xy-plane. Also, for a polarized magnetic field, exchange E with HZ and HZ with -E. \n\nArguments\n\nrf: 2D float array of size Ntimes 3 containing the positions (units of length) where the field is calculated.\nknorm: wavenumber in the medium.\nbw0: float with the beam waist radius.\nn: non-negative int with the radial order of the beam.\nm: int with the azimuthal order of the beam.\ne0: scalar with the modulus of the electric field (see theory for more details). \nkmax: float setting the limit of the radial integration (it shoud be kmax < k).\nmaxe: maximum number of evaluations in the adapative integral (see Cubature.jl for more details).\n\nOutputs\n\nphi_laguerre: 2D complex array of size Ntimes 6 with the value of the field at each position.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/#Derivatives-of-the-Beams","page":"InputFields","title":"Derivatives of the Beams","text":"","category":"section"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e","text":"d_plane_wave_e(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the derivatives of an electric field generated with plane_wave_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_plane_wave_e_m","text":"d_plane_wave_e_m(kr;khat=[0,0,1],e0=[1,0,0])\n\nComputes the derivatives of an electromagnetic field generated with plane_wave_e_m (the arguments are the same). Outputs three 2D arrays of size `N\\times 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e","text":"d_point_dipole_e(krf, krd, dip, e0=1)\n\nComputes the derivatives of an electric field generated with point_dipole_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_point_dipole_e_m","text":"d_point_dipole_e_m(krf, krd, dip, e0=1)\n\nComputes the derivatives of an electromagnetic field generated with point_dipole_e_m (the arguments are the same). Outputs three 2D arrays of size `N\\times 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e","text":"d_gauss_beam_e(rf,knorm,bw0; e0 = 1, kmax = nothing, maxe = Int(5e3))\n\nComputes the derivatives of an electric field generated with gauss_beam_e (the arguments are the same). Outputs three 2D arrays of size Ntimes 3 containing the field derivatives with respect k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"input_fields/","page":"InputFields","title":"InputFields","text":"CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e_m","category":"page"},{"location":"input_fields/#Main.CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e_m","page":"InputFields","title":"Main.CoupledElectricMagneticDipoles.InputFields.d_gauss_beam_e_m","text":"d_gauss_beam_e_m(rf,knorm,bw0; e0 = 1, kmax = nothing, maxe = Int(5e3))\n\nComputes the derivatives of an electromagnetic field generated with gauss_beam_e_m (the arguments are the same). Outputs three 2D arrays of size `N\\times 6 containing the field derivatives with respect of k*x, k*y and k*z.\n\n\n\n\n\n","category":"function"},{"location":"#CoupledElectricMagneticDipoles.jl","page":"Home","title":"CoupledElectricMagneticDipoles.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome on the documentation website for the coupled electric and magnetic dipoles (CEMD), or discrete dipoles approximation (DDA) method implementation in Julia! On this website, you will find all the description of the functions implemented in this library. Please, read carefully the next sections in order to be ready to code with CoupledElectricMagneticDipoles.jl!","category":"page"},{"location":"#How-to-Use-this-Website-and-Learn-the-Library?","page":"Home","title":"How to Use this Website and Learn the Library?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This website is divided in three parts. The first one is the home page, in which you will find all the informations to install, run and begin tu use the package. You will find as well a theory section containing the definitions of the CEMD (DDA) problems and all the mathematical expressions that are used to implement the functions. The second part is dedicated to the 7 submodules of the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DDACore: Contains the functions to solve the coupled dipoles system of equations.\nAlphas: Small module to compute the polarizabilities.\nInputFields: Module with functions for input fields.\nPostProcessing: Module used to compute the scattering, absorption and extinction cross sections, as well as the scattered field and local density of states (LDOS).\nForces: Module to compute optical forces between on dipoles.\nGreenTensors: Contains functions to compute the electric and magnetic or both green tensors.\nGeometries: Small library to discretize some 3D primitives.\nMieCoeff: Contains functions to compute the Mie coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the example tab gives three examples for the use of this library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please have a look to the theory (next section) and the remaining of this page before starting. When ready, have a look to the examples. Note that functions that ends in -_e are for systems made out of electric dipoles only and functions ending in -_e_m are for system with both electric and magnetic dipoles.","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please read carefully the theory if you don't know about CEMD (DDA) method. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p>You can download the theory here: <a href=\"assets/CoupledElectricMagneticDipoles.pdf\">Download PDF</a>.</p>","category":"page"},{"location":"#Installing-the-Library","page":"Home","title":"Installing the Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since the library is not yet in the big registery of the julia package manager, you have to download the CoupledElectricMagneticDipoles in local in order to use it. In order to be able to run it, please run in your julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add \"path to the library\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this, the package will be precompiled and the dependancies are going to be installed. Then, you will be able to import the library, by using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CoupledElectricMagneticDipoles","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the library is installed and activated,we strongly recommand you to try to run one example to see if everything's works well.","category":"page"},{"location":"#About-the-Units","page":"Home","title":"About the Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computers are dealing with number without units. Therefore, most of the inputs in the functions are dimensionless. For this, some renormalization may be needed. The most used are for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Positions mathbfr (units of L) are multiplied by the wavenumber k (units of L⁻¹), in order to get dimensionless positions kr.\nPolarizabilities have units of volume (L³). We renormalize it by a factor k^34pi (units of L⁻³) in oder to get dimensionless polarizabilities.\nMagnetic field is multiplied by the impedence Z in the medium. For this, we get a magnetic field that has the sames units as the electric field (E,H) becomes (E,ZH). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some functions are not using only dimensionless inputs. In all cases, this is the user's responsability to send inputs that are coherents in terms of units. ","category":"page"},{"location":"#Running-the-Package-in-Parallel","page":"Home","title":"Running the Package in Parallel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Solving the DDA system of equations can be done with two different method that are parallel:","category":"page"},{"location":"","page":"Home","title":"Home","text":"With LAPACK LU decomposition on multiple CPU (the number of BLAS threads is set to be equal to the number of julia threads).\nWith LU decomposition on the GPU (CUDA), by offloading the system on equations in the GPU memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To choose how to set the solver, see the DDACore module library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On the other hand, some of the functions of the library are paralelized in the shared-memory scheme using the julia build-in parallelization. To use it, just set the number of threads to use when you run a julia script. Just like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --threads=8 foo.jl","category":"page"},{"location":"#Importing-the-Package-in-Python","page":"Home","title":"Importing the Package in Python","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is possible to run the package from python. See the PyJulia package and the examples in order to learn how to do this.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite this software, please use: ....","category":"page"},{"location":"","page":"Home","title":"Home","text":"Authors: Augustin Muster, Diego Romero Abujetas, Luis S. Froufe-Pérez.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Contact email: augustin@must-r.com","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are open to any comments, ideas or questions about this software. Don't hesitate to write us, but please be aware that we are not guaranteeing support.","category":"page"}]
}
